(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{176:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return escapeHtml; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return format; });\n/* unused harmony export friendlyJSONstringify */\n/* unused harmony export generateCodeFrame */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return generateFormatCacheKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return getGlobalThis; });\n/* unused harmony export inBrowser */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return isBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return isDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return isEmptyObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return isPlainObject; });\n/* unused harmony export isPromise */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return isRegExp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return isString; });\n/* unused harmony export isSymbol */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"o\", function() { return makeSymbol; });\n/* unused harmony export mark */\n/* unused harmony export measure */\n/* unused harmony export objectToString */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"p\", function() { return toDisplayString; });\n/* unused harmony export toTypeString */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"q\", function() { return warn; });\n/*!\n  * @intlify/shared v9.0.0-beta.14\n  * (c) 2020 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n/**\r\n * Original Utilities\r\n * written by kazuya kawaguchi\r\n */\r\nconst inBrowser = typeof window !== 'undefined';\r\nlet mark;\r\nlet measure;\r\nif ((false)) {}\r\nconst RE_ARGS = /\\{([0-9a-zA-Z]+)\\}/g;\r\n/* eslint-disable */\r\nfunction format(message, ...args) {\r\n    if (args.length === 1 && isObject(args[0])) {\r\n        args = args[0];\r\n    }\r\n    if (!args || !args.hasOwnProperty) {\r\n        args = {};\r\n    }\r\n    return message.replace(RE_ARGS, (match, identifier) => {\r\n        return args.hasOwnProperty(identifier) ? args[identifier] : '';\r\n    });\r\n}\r\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst makeSymbol = (name) => hasSymbol ? Symbol(name) : name;\r\nconst generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });\r\nconst friendlyJSONstringify = (json) => JSON.stringify(json)\r\n    .replace(/\\u2028/g, '\\\\u2028')\r\n    .replace(/\\u2029/g, '\\\\u2029')\r\n    .replace(/\\u0027/g, '\\\\u0027');\r\nconst isNumber = (val) => typeof val === 'number' && isFinite(val);\r\nconst isDate = (val) => toTypeString(val) === '[object Date]';\r\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\r\nconst isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;\r\nfunction warn(msg, err) {\r\n    if (typeof console !== 'undefined') {\r\n        const label =  'intlify' ;\r\n        console.warn(`[${label}] ` + msg);\r\n        /* istanbul ignore if */\r\n        if (err) {\r\n            console.warn(err.stack);\r\n        }\r\n    }\r\n}\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    // prettier-ignore\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\r\nfunction escapeHtml(rawText) {\r\n    return rawText\r\n        .replace(/</g, '&lt;')\r\n        .replace(/>/g, '&gt;')\r\n        .replace(/\"/g, '&quot;')\r\n        .replace(/'/g, '&apos;');\r\n}\r\n/* eslint-enable */\r\n/**\r\n * Useful Utilites By Evan you\r\n * Modified by kazuya kawaguchi\r\n * MIT License\r\n * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts\r\n * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/codeframe.ts\r\n */\r\nconst isArray = Array.isArray;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isBoolean = (val) => typeof val === 'boolean';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => // eslint-disable-line\r\n val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\n// for converting list and named values to displayed strings.\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isArray(val) || (isPlainObject(val) && val.toString === objectToString)\r\n            ? JSON.stringify(val, null, 2)\r\n            : String(val);\r\n};\r\nconst RANGE = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    const lines = source.split(/\\r?\\n/);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (let j = i - RANGE; j <= i + RANGE || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - lineLength) + 1;\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))\n\n//# sourceURL=webpack:///./node_modules/@intlify/shared/dist/shared.esm-bundler.js?")},574:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ createI18n; });\n\n// UNUSED EXPORTS: DatetimeFormat, NumberFormat, Translation, VERSION, useI18n, vTDirective\n\n// EXTERNAL MODULE: ./node_modules/@intlify/shared/dist/shared.esm-bundler.js\nvar shared_esm_bundler = __webpack_require__(176);\n\n// EXTERNAL MODULE: ./node_modules/@vue/devtools-api/lib/index.js\nvar lib = __webpack_require__(897);\n\n// CONCATENATED MODULE: ./node_modules/@intlify/message-resolver/dist/message-resolver.esm-bundler.js\n/*!\n  * @intlify/message-resolver v9.0.0-beta.14\n  * (c) 2020 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n/**\r\n * Original Utilities\r\n * written by kazuya kawaguchi\r\n */\r\nif ((false)) {}\r\nconst isObject = (val) => // eslint-disable-line\r\n val !== null && typeof val === \'object\';\n\nconst pathStateMachine = [];\r\npathStateMachine[0 /* BEFORE_PATH */] = {\r\n    ["w" /* WORKSPACE */]: [0 /* BEFORE_PATH */],\r\n    ["i" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    ["[" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],\r\n    ["o" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]\r\n};\r\npathStateMachine[1 /* IN_PATH */] = {\r\n    ["w" /* WORKSPACE */]: [1 /* IN_PATH */],\r\n    ["." /* DOT */]: [2 /* BEFORE_IDENT */],\r\n    ["[" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],\r\n    ["o" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]\r\n};\r\npathStateMachine[2 /* BEFORE_IDENT */] = {\r\n    ["w" /* WORKSPACE */]: [2 /* BEFORE_IDENT */],\r\n    ["i" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    ["0" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */]\r\n};\r\npathStateMachine[3 /* IN_IDENT */] = {\r\n    ["i" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    ["0" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */],\r\n    ["w" /* WORKSPACE */]: [1 /* IN_PATH */, 1 /* PUSH */],\r\n    ["." /* DOT */]: [2 /* BEFORE_IDENT */, 1 /* PUSH */],\r\n    ["[" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */, 1 /* PUSH */],\r\n    ["o" /* END_OF_FAIL */]: [7 /* AFTER_PATH */, 1 /* PUSH */]\r\n};\r\npathStateMachine[4 /* IN_SUB_PATH */] = {\r\n    ["\'" /* SINGLE_QUOTE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */],\r\n    ["\\"" /* DOUBLE_QUOTE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */],\r\n    ["[" /* LEFT_BRACKET */]: [\r\n        4 /* IN_SUB_PATH */,\r\n        2 /* INC_SUB_PATH_DEPTH */\r\n    ],\r\n    ["]" /* RIGHT_BRACKET */]: [1 /* IN_PATH */, 3 /* PUSH_SUB_PATH */],\r\n    ["o" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    ["l" /* ELSE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */]\r\n};\r\npathStateMachine[5 /* IN_SINGLE_QUOTE */] = {\r\n    ["\'" /* SINGLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],\r\n    ["o" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    ["l" /* ELSE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */]\r\n};\r\npathStateMachine[6 /* IN_DOUBLE_QUOTE */] = {\r\n    ["\\"" /* DOUBLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],\r\n    ["o" /* END_OF_FAIL */]: 8 /* ERROR */,\r\n    ["l" /* ELSE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */]\r\n};\r\n/**\r\n * Check if an expression is a literal value.\r\n */\r\nconst literalValueRE = /^\\s?(?:true|false|-?[\\d.]+|\'[^\']*\'|"[^"]*")\\s?$/;\r\nfunction isLiteral(exp) {\r\n    return literalValueRE.test(exp);\r\n}\r\n/**\r\n * Strip quotes from a string\r\n */\r\nfunction stripQuotes(str) {\r\n    const a = str.charCodeAt(0);\r\n    const b = str.charCodeAt(str.length - 1);\r\n    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\r\n}\r\n/**\r\n * Determine the type of a character in a keypath.\r\n */\r\nfunction getPathCharType(ch) {\r\n    if (ch === undefined || ch === null) {\r\n        return "o" /* END_OF_FAIL */;\r\n    }\r\n    const code = ch.charCodeAt(0);\r\n    switch (code) {\r\n        case 0x5b: // [\r\n        case 0x5d: // ]\r\n        case 0x2e: // .\r\n        case 0x22: // "\r\n        case 0x27: // \'\r\n            return ch;\r\n        case 0x5f: // _\r\n        case 0x24: // $\r\n        case 0x2d: // -\r\n            return "i" /* IDENT */;\r\n        case 0x09: // Tab (HT)\r\n        case 0x0a: // Newline (LF)\r\n        case 0x0d: // Return (CR)\r\n        case 0xa0: // No-break space (NBSP)\r\n        case 0xfeff: // Byte Order Mark (BOM)\r\n        case 0x2028: // Line Separator (LS)\r\n        case 0x2029: // Paragraph Separator (PS)\r\n            return "w" /* WORKSPACE */;\r\n    }\r\n    return "i" /* IDENT */;\r\n}\r\n/**\r\n * Format a subPath, return its plain form if it is\r\n * a literal string or number. Otherwise prepend the\r\n * dynamic indicator (*).\r\n */\r\nfunction formatSubPath(path) {\r\n    const trimmed = path.trim();\r\n    // invalid leading 0\r\n    if (path.charAt(0) === \'0\' && isNaN(parseInt(path))) {\r\n        return false;\r\n    }\r\n    return isLiteral(trimmed)\r\n        ? stripQuotes(trimmed)\r\n        : "*" /* ASTARISK */ + trimmed;\r\n}\r\n/**\r\n * Parse a string path into an array of segments\r\n */\r\nfunction parse(path) {\r\n    const keys = [];\r\n    let index = -1;\r\n    let mode = 0 /* BEFORE_PATH */;\r\n    let subPathDepth = 0;\r\n    let c;\r\n    let key; // eslint-disable-line\r\n    let newChar;\r\n    let type;\r\n    let transition;\r\n    let action;\r\n    let typeMap;\r\n    const actions = [];\r\n    actions[0 /* APPEND */] = () => {\r\n        if (key === undefined) {\r\n            key = newChar;\r\n        }\r\n        else {\r\n            key += newChar;\r\n        }\r\n    };\r\n    actions[1 /* PUSH */] = () => {\r\n        if (key !== undefined) {\r\n            keys.push(key);\r\n            key = undefined;\r\n        }\r\n    };\r\n    actions[2 /* INC_SUB_PATH_DEPTH */] = () => {\r\n        actions[0 /* APPEND */]();\r\n        subPathDepth++;\r\n    };\r\n    actions[3 /* PUSH_SUB_PATH */] = () => {\r\n        if (subPathDepth > 0) {\r\n            subPathDepth--;\r\n            mode = 4 /* IN_SUB_PATH */;\r\n            actions[0 /* APPEND */]();\r\n        }\r\n        else {\r\n            subPathDepth = 0;\r\n            if (key === undefined) {\r\n                return false;\r\n            }\r\n            key = formatSubPath(key);\r\n            if (key === false) {\r\n                return false;\r\n            }\r\n            else {\r\n                actions[1 /* PUSH */]();\r\n            }\r\n        }\r\n    };\r\n    function maybeUnescapeQuote() {\r\n        const nextChar = path[index + 1];\r\n        if ((mode === 5 /* IN_SINGLE_QUOTE */ &&\r\n            nextChar === "\'" /* SINGLE_QUOTE */) ||\r\n            (mode === 6 /* IN_DOUBLE_QUOTE */ &&\r\n                nextChar === "\\"" /* DOUBLE_QUOTE */)) {\r\n            index++;\r\n            newChar = \'\\\\\' + nextChar;\r\n            actions[0 /* APPEND */]();\r\n            return true;\r\n        }\r\n    }\r\n    while (mode !== null) {\r\n        index++;\r\n        c = path[index];\r\n        if (c === \'\\\\\' && maybeUnescapeQuote()) {\r\n            continue;\r\n        }\r\n        type = getPathCharType(c);\r\n        typeMap = pathStateMachine[mode];\r\n        transition = typeMap[type] || typeMap["l" /* ELSE */] || 8 /* ERROR */;\r\n        // check parse error\r\n        if (transition === 8 /* ERROR */) {\r\n            return;\r\n        }\r\n        mode = transition[0];\r\n        if (transition[1] !== undefined) {\r\n            action = actions[transition[1]];\r\n            if (action) {\r\n                newChar = c;\r\n                if (action() === false) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        // check parse finish\r\n        if (mode === 7 /* AFTER_PATH */) {\r\n            return keys;\r\n        }\r\n    }\r\n}\r\n// path token cache\r\nconst cache = new Map();\r\nfunction resolveValue(obj, path) {\r\n    // check object\r\n    if (!isObject(obj)) {\r\n        return null;\r\n    }\r\n    // parse path\r\n    let hit = cache.get(path);\r\n    if (!hit) {\r\n        hit = parse(path);\r\n        if (hit) {\r\n            cache.set(path, hit);\r\n        }\r\n    }\r\n    // check hit\r\n    if (!hit) {\r\n        return null;\r\n    }\r\n    // resolve path value\r\n    const len = hit.length;\r\n    let last = obj;\r\n    let i = 0;\r\n    while (i < len) {\r\n        const val = last[hit[i]];\r\n        if (val === undefined) {\r\n            return null;\r\n        }\r\n        last = val;\r\n        i++;\r\n    }\r\n    return last;\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@intlify/runtime/dist/runtime.esm-bundler.js\n/*!\n  * @intlify/runtime v9.0.0-beta.14\n  * (c) 2020 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n\nconst DEFAULT_MODIFIER = (str) => str;\r\nconst DEFAULT_MESSAGE = (ctx) => \'\'; // eslint-disable-line\r\nconst DEFAULT_MESSAGE_DATA_TYPE = \'text\';\r\nconst DEFAULT_NORMALIZE = (values) => values.length === 0 ? \'\' : values.join(\'\');\r\nconst DEFAULT_INTERPOLATE = shared_esm_bundler["p" /* toDisplayString */];\r\nfunction pluralDefault(choice, choicesLength) {\r\n    choice = Math.abs(choice);\r\n    if (choicesLength === 2) {\r\n        // prettier-ignore\r\n        return choice\r\n            ? choice > 1\r\n                ? 1\r\n                : 0\r\n            : 1;\r\n    }\r\n    return choice ? Math.min(choice, 2) : 0;\r\n}\r\nfunction getPluralIndex(options) {\r\n    // prettier-ignore\r\n    const index = Object(shared_esm_bundler["j" /* isNumber */])(options.pluralIndex)\r\n        ? options.pluralIndex\r\n        : -1;\r\n    // prettier-ignore\r\n    return options.named && (Object(shared_esm_bundler["j" /* isNumber */])(options.named.count) || Object(shared_esm_bundler["j" /* isNumber */])(options.named.n))\r\n        ? Object(shared_esm_bundler["j" /* isNumber */])(options.named.count)\r\n            ? options.named.count\r\n            : Object(shared_esm_bundler["j" /* isNumber */])(options.named.n)\r\n                ? options.named.n\r\n                : index\r\n        : index;\r\n}\r\nfunction normalizeNamed(pluralIndex, props) {\r\n    if (!props.count) {\r\n        props.count = pluralIndex;\r\n    }\r\n    if (!props.n) {\r\n        props.n = pluralIndex;\r\n    }\r\n}\r\nfunction createMessageContext(options = {}) {\r\n    const locale = options.locale;\r\n    const pluralIndex = getPluralIndex(options);\r\n    const pluralRule = Object(shared_esm_bundler["k" /* isObject */])(options.pluralRules) &&\r\n        Object(shared_esm_bundler["n" /* isString */])(locale) &&\r\n        Object(shared_esm_bundler["i" /* isFunction */])(options.pluralRules[locale])\r\n        ? options.pluralRules[locale]\r\n        : pluralDefault;\r\n    const orgPluralRule = Object(shared_esm_bundler["k" /* isObject */])(options.pluralRules) &&\r\n        Object(shared_esm_bundler["n" /* isString */])(locale) &&\r\n        Object(shared_esm_bundler["i" /* isFunction */])(options.pluralRules[locale])\r\n        ? pluralDefault\r\n        : undefined;\r\n    const plural = (messages) => messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];\r\n    const _list = options.list || [];\r\n    const list = (index) => _list[index];\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const _named = options.named || {};\r\n    Object(shared_esm_bundler["j" /* isNumber */])(options.pluralIndex) && normalizeNamed(pluralIndex, _named);\r\n    const named = (key) => _named[key];\r\n    // TODO: need to design resolve message function?\r\n    function message(key) {\r\n        // prettier-ignore\r\n        const msg = Object(shared_esm_bundler["i" /* isFunction */])(options.messages)\r\n            ? options.messages(key)\r\n            : Object(shared_esm_bundler["k" /* isObject */])(options.messages)\r\n                ? options.messages[key]\r\n                : false;\r\n        return !msg\r\n            ? options.parent\r\n                ? options.parent.message(key) // resolve from parent messages\r\n                : DEFAULT_MESSAGE\r\n            : msg;\r\n    }\r\n    const _modifier = (name) => options.modifiers\r\n        ? options.modifiers[name]\r\n        : DEFAULT_MODIFIER;\r\n    const normalize = Object(shared_esm_bundler["l" /* isPlainObject */])(options.processor) && Object(shared_esm_bundler["i" /* isFunction */])(options.processor.normalize)\r\n        ? options.processor.normalize\r\n        : DEFAULT_NORMALIZE;\r\n    const interpolate = Object(shared_esm_bundler["l" /* isPlainObject */])(options.processor) &&\r\n        Object(shared_esm_bundler["i" /* isFunction */])(options.processor.interpolate)\r\n        ? options.processor.interpolate\r\n        : DEFAULT_INTERPOLATE;\r\n    const type = Object(shared_esm_bundler["l" /* isPlainObject */])(options.processor) && Object(shared_esm_bundler["n" /* isString */])(options.processor.type)\r\n        ? options.processor.type\r\n        : DEFAULT_MESSAGE_DATA_TYPE;\r\n    const ctx = {\r\n        ["list" /* LIST */]: list,\r\n        ["named" /* NAMED */]: named,\r\n        ["plural" /* PLURAL */]: plural,\r\n        ["linked" /* LINKED */]: (key, modifier) => {\r\n            // TODO: should check `key`\r\n            const msg = message(key)(ctx);\r\n            return Object(shared_esm_bundler["n" /* isString */])(modifier) ? _modifier(modifier)(msg) : msg;\r\n        },\r\n        ["message" /* MESSAGE */]: message,\r\n        ["type" /* TYPE */]: type,\r\n        ["interpolate" /* INTERPOLATE */]: interpolate,\r\n        ["normalize" /* NORMALIZE */]: normalize\r\n    };\r\n    return ctx;\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@intlify/message-compiler/dist/message-compiler.esm-bundler.js\n/*!\n  * @intlify/message-compiler v9.0.0-beta.14\n  * (c) 2020 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n\n/** @internal */\r\nconst errorMessages = {\r\n    // tokenizer error messages\r\n    [0 /* EXPECTED_TOKEN */]: `Expected token: \'{0}\'`,\r\n    [1 /* INVALID_TOKEN_IN_PLACEHOLDER */]: `Invalid token in placeholder: \'{0}\'`,\r\n    [2 /* UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER */]: `Unterminated single quote in placeholder`,\r\n    [3 /* UNKNOWN_ESCAPE_SEQUENCE */]: `Unknown escape sequence: \\\\{0}`,\r\n    [4 /* INVALID_UNICODE_ESCAPE_SEQUENCE */]: `Invalid unicode escape sequence: {0}`,\r\n    [5 /* UNBALANCED_CLOSING_BRACE */]: `Unbalanced closing brace`,\r\n    [6 /* UNTERMINATED_CLOSING_BRACE */]: `Unterminated closing brace`,\r\n    [7 /* EMPTY_PLACEHOLDER */]: `Empty placeholder`,\r\n    [8 /* NOT_ALLOW_NEST_PLACEHOLDER */]: `Not allowed nest placeholder`,\r\n    [9 /* INVALID_LINKED_FORMAT */]: `Invalid linked format`,\r\n    // parser error messages\r\n    [10 /* MUST_HAVE_MESSAGES_IN_PLURAL */]: `Plural must have messages`,\r\n    [11 /* UNEXPECTED_LEXICAL_ANALYSIS */]: `Unexpected lexical analysis in token: \'{0}\'`\r\n};\r\nfunction createCompileError(code, loc, optinos = {}) {\r\n    const { domain, messages, args } = optinos;\r\n    const msg = ( false)\r\n        ? undefined\r\n        : code;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    if (loc) {\r\n        error.location = loc;\r\n    }\r\n    error.domain = domain;\r\n    return error;\r\n}\r\n/** @internal */\r\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\n\nconst LocationStub = {\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createPosition(line, column, offset) {\r\n    return { line, column, offset };\r\n}\r\nfunction createLocation(start, end, source) {\r\n    const loc = { start, end };\r\n    if (source != null) {\r\n        loc.source = source;\r\n    }\r\n    return loc;\r\n}\n\nconst CHAR_SP = \' \';\r\nconst CHAR_CR = \'\\r\';\r\nconst CHAR_LF = \'\\n\';\r\nconst CHAR_LS = String.fromCharCode(0x2028);\r\nconst CHAR_PS = String.fromCharCode(0x2029);\r\nfunction createScanner(str) {\r\n    const _buf = str;\r\n    let _index = 0;\r\n    let _line = 1;\r\n    let _column = 1;\r\n    let _peekOffset = 0;\r\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\r\n    const isLF = (index) => _buf[index] === CHAR_LF;\r\n    const isPS = (index) => _buf[index] === CHAR_PS;\r\n    const isLS = (index) => _buf[index] === CHAR_LS;\r\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\r\n    const index = () => _index;\r\n    const line = () => _line;\r\n    const column = () => _column;\r\n    const peekOffset = () => _peekOffset;\r\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\r\n    const currentChar = () => charAt(_index);\r\n    const currentPeek = () => charAt(_index + _peekOffset);\r\n    function next() {\r\n        _peekOffset = 0;\r\n        if (isLineEnd(_index)) {\r\n            _line++;\r\n            _column = 0;\r\n        }\r\n        if (isCRLF(_index)) {\r\n            _index++;\r\n        }\r\n        _index++;\r\n        _column++;\r\n        return _buf[_index];\r\n    }\r\n    function peek() {\r\n        if (isCRLF(_index + _peekOffset)) {\r\n            _peekOffset++;\r\n        }\r\n        _peekOffset++;\r\n        return _buf[_index + _peekOffset];\r\n    }\r\n    function reset() {\r\n        _index = 0;\r\n        _line = 1;\r\n        _column = 1;\r\n        _peekOffset = 0;\r\n    }\r\n    function resetPeek(offset = 0) {\r\n        _peekOffset = offset;\r\n    }\r\n    function skipToPeek() {\r\n        const target = _index + _peekOffset;\r\n        // eslint-disable-next-line no-unmodified-loop-condition\r\n        while (target !== _index) {\r\n            next();\r\n        }\r\n        _peekOffset = 0;\r\n    }\r\n    return {\r\n        index,\r\n        line,\r\n        column,\r\n        peekOffset,\r\n        charAt,\r\n        currentChar,\r\n        currentPeek,\r\n        next,\r\n        peek,\r\n        reset,\r\n        resetPeek,\r\n        skipToPeek\r\n    };\r\n}\n\nconst EOF = undefined;\r\nconst LITERAL_DELIMITER = "\'";\r\nconst ERROR_DOMAIN = \'tokenizer\';\r\nfunction createTokenizer(source, options = {}) {\r\n    const location = !options.location;\r\n    const _scnr = createScanner(source);\r\n    const currentOffset = () => _scnr.index();\r\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\r\n    const _initLoc = currentPosition();\r\n    const _initOffset = currentOffset();\r\n    const _context = {\r\n        currentType: 14 /* EOF */,\r\n        offset: _initOffset,\r\n        startLoc: _initLoc,\r\n        endLoc: _initLoc,\r\n        lastType: 14 /* EOF */,\r\n        lastOffset: _initOffset,\r\n        lastStartLoc: _initLoc,\r\n        lastEndLoc: _initLoc,\r\n        braceNest: 0,\r\n        inLinked: false,\r\n        text: \'\'\r\n    };\r\n    const context = () => _context;\r\n    const { onError } = options;\r\n    function emitError(code, pos, offset, ...args) {\r\n        const ctx = context();\r\n        pos.column += offset;\r\n        pos.offset += offset;\r\n        if (onError) {\r\n            const loc = createLocation(ctx.startLoc, pos);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function getToken(context, type, value) {\r\n        context.endLoc = currentPosition();\r\n        context.currentType = type;\r\n        const token = { type };\r\n        if (location) {\r\n            token.loc = createLocation(context.startLoc, context.endLoc);\r\n        }\r\n        if (value != null) {\r\n            token.value = value;\r\n        }\r\n        return token;\r\n    }\r\n    const getEndToken = (context) => getToken(context, 14 /* EOF */);\r\n    function eat(scnr, ch) {\r\n        if (scnr.currentChar() === ch) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        else {\r\n            emitError(0 /* EXPECTED_TOKEN */, currentPosition(), 0, ch);\r\n            return \'\';\r\n        }\r\n    }\r\n    function peekSpaces(scnr) {\r\n        let buf = \'\';\r\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\r\n            buf += scnr.currentPeek();\r\n            scnr.peek();\r\n        }\r\n        return buf;\r\n    }\r\n    function skipSpaces(scnr) {\r\n        const buf = peekSpaces(scnr);\r\n        scnr.skipToPeek();\r\n        return buf;\r\n    }\r\n    function isIdentifierStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return ((cc >= 97 && cc <= 122) || // a-z\r\n            (cc >= 65 && cc <= 90)); // A-Z\r\n    }\r\n    function isNumberStart(ch) {\r\n        if (ch === EOF) {\r\n            return false;\r\n        }\r\n        const cc = ch.charCodeAt(0);\r\n        return cc >= 48 && cc <= 57; // 0-9\r\n    }\r\n    function isNamedIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isListIdentifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ch = scnr.currentPeek() === \'-\' ? scnr.peek() : scnr.currentPeek();\r\n        const ret = isNumberStart(ch);\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLiteralStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 2 /* BraceLeft */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDotStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 8 /* LinkedAlias */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === "." /* LinkedDot */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedModifierStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 9 /* LinkedDot */) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = isIdentifierStart(scnr.currentPeek());\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedDelimiterStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (!(currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 12 /* LinkedModifier */)) {\r\n            return false;\r\n        }\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === ":" /* LinkedDelimiter */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isLinkedReferStart(scnr, context) {\r\n        const { currentType } = context;\r\n        if (currentType !== 10 /* LinkedDelimiter */) {\r\n            return false;\r\n        }\r\n        const fn = () => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === "{" /* BraceLeft */) {\r\n                return isIdentifierStart(scnr.peek());\r\n            }\r\n            else if (ch === "@" /* LinkedAlias */ ||\r\n                ch === "%" /* Modulo */ ||\r\n                ch === "|" /* Pipe */ ||\r\n                ch === ":" /* LinkedDelimiter */ ||\r\n                ch === "." /* LinkedDot */ ||\r\n                ch === CHAR_SP ||\r\n                !ch) {\r\n                return false;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn();\r\n            }\r\n            else {\r\n                // other charactors\r\n                return isIdentifierStart(ch);\r\n            }\r\n        };\r\n        const ret = fn();\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isPluralStart(scnr) {\r\n        peekSpaces(scnr);\r\n        const ret = scnr.currentPeek() === "|" /* Pipe */;\r\n        scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function isTextStart(scnr, reset = true) {\r\n        const fn = (hasSpace = false, prev = \'\', detectModulo = false) => {\r\n            const ch = scnr.currentPeek();\r\n            if (ch === "{" /* BraceLeft */) {\r\n                return prev === "%" /* Modulo */ ? false : hasSpace;\r\n            }\r\n            else if (ch === "@" /* LinkedAlias */ || !ch) {\r\n                return prev === "%" /* Modulo */ ? true : hasSpace;\r\n            }\r\n            else if (ch === "%" /* Modulo */) {\r\n                scnr.peek();\r\n                return fn(hasSpace, "%" /* Modulo */, true);\r\n            }\r\n            else if (ch === "|" /* Pipe */) {\r\n                return prev === "%" /* Modulo */ || detectModulo\r\n                    ? true\r\n                    : !(prev === CHAR_SP || prev === CHAR_LF);\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_SP, detectModulo);\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                scnr.peek();\r\n                return fn(true, CHAR_LF, detectModulo);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        };\r\n        const ret = fn();\r\n        reset && scnr.resetPeek();\r\n        return ret;\r\n    }\r\n    function takeChar(scnr, fn) {\r\n        const ch = scnr.currentChar();\r\n        if (ch === EOF) {\r\n            return EOF;\r\n        }\r\n        if (fn(ch)) {\r\n            scnr.next();\r\n            return ch;\r\n        }\r\n        return null;\r\n    }\r\n    function takeIdentifierChar(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 97 && cc <= 122) || // a-z\r\n                (cc >= 65 && cc <= 90) || // A-Z\r\n                (cc >= 48 && cc <= 57) || // 0-9\r\n                cc === 95 ||\r\n                cc === 36); // _ $\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return cc >= 48 && cc <= 57; // 0-9\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function takeHexDigit(scnr) {\r\n        const closure = (ch) => {\r\n            const cc = ch.charCodeAt(0);\r\n            return ((cc >= 48 && cc <= 57) || // 0-9\r\n                (cc >= 65 && cc <= 70) || // A-F\r\n                (cc >= 97 && cc <= 102)); // a-f\r\n        };\r\n        return takeChar(scnr, closure);\r\n    }\r\n    function getDigits(scnr) {\r\n        let ch = \'\';\r\n        let num = \'\';\r\n        while ((ch = takeDigit(scnr))) {\r\n            num += ch;\r\n        }\r\n        return num;\r\n    }\r\n    function readText(scnr) {\r\n        const fn = (buf) => {\r\n            const ch = scnr.currentChar();\r\n            if (ch === "{" /* BraceLeft */ ||\r\n                ch === "}" /* BraceRight */ ||\r\n                ch === "@" /* LinkedAlias */ ||\r\n                !ch) {\r\n                return buf;\r\n            }\r\n            else if (ch === "%" /* Modulo */) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                    return fn(buf);\r\n                }\r\n                else {\r\n                    return buf;\r\n                }\r\n            }\r\n            else if (ch === "|" /* Pipe */) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\r\n                if (isTextStart(scnr)) {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                    return fn(buf);\r\n                }\r\n                else if (isPluralStart(scnr)) {\r\n                    return buf;\r\n                }\r\n                else {\r\n                    buf += ch;\r\n                    scnr.next();\r\n                    return fn(buf);\r\n                }\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(buf);\r\n            }\r\n        };\r\n        return fn(\'\');\r\n    }\r\n    function readNamedIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = \'\';\r\n        let name = \'\';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(6 /* UNTERMINATED_CLOSING_BRACE */, currentPosition(), 0);\r\n        }\r\n        return name;\r\n    }\r\n    function readListIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let value = \'\';\r\n        if (scnr.currentChar() === \'-\') {\r\n            scnr.next();\r\n            value += `-${getDigits(scnr)}`;\r\n        }\r\n        else {\r\n            value += getDigits(scnr);\r\n        }\r\n        if (scnr.currentChar() === EOF) {\r\n            emitError(6 /* UNTERMINATED_CLOSING_BRACE */, currentPosition(), 0);\r\n        }\r\n        return value;\r\n    }\r\n    function readLiteral(scnr) {\r\n        skipSpaces(scnr);\r\n        eat(scnr, `\\\'`);\r\n        let ch = \'\';\r\n        let literal = \'\';\r\n        const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, fn))) {\r\n            if (ch === \'\\\\\') {\r\n                literal += readEscapeSequence(scnr);\r\n            }\r\n            else {\r\n                literal += ch;\r\n            }\r\n        }\r\n        const current = scnr.currentChar();\r\n        if (current === CHAR_LF || current === EOF) {\r\n            emitError(2 /* UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER */, currentPosition(), 0);\r\n            // TODO: Is it correct really?\r\n            if (current === CHAR_LF) {\r\n                scnr.next();\r\n                eat(scnr, `\\\'`);\r\n            }\r\n            return literal;\r\n        }\r\n        eat(scnr, `\\\'`);\r\n        return literal;\r\n    }\r\n    function readEscapeSequence(scnr) {\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case \'\\\\\':\r\n            case `\\\'`:\r\n                scnr.next();\r\n                return `\\\\${ch}`;\r\n            case \'u\':\r\n                return readUnicodeEscapeSequence(scnr, ch, 4);\r\n            case \'U\':\r\n                return readUnicodeEscapeSequence(scnr, ch, 6);\r\n            default:\r\n                emitError(3 /* UNKNOWN_ESCAPE_SEQUENCE */, currentPosition(), 0, ch);\r\n                return \'\';\r\n        }\r\n    }\r\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\r\n        eat(scnr, unicode);\r\n        let sequence = \'\';\r\n        for (let i = 0; i < digits; i++) {\r\n            const ch = takeHexDigit(scnr);\r\n            if (!ch) {\r\n                emitError(4 /* INVALID_UNICODE_ESCAPE_SEQUENCE */, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\r\n                break;\r\n            }\r\n            sequence += ch;\r\n        }\r\n        return `\\\\${unicode}${sequence}`;\r\n    }\r\n    function readInvalidIdentifier(scnr) {\r\n        skipSpaces(scnr);\r\n        let ch = \'\';\r\n        let identifiers = \'\';\r\n        const closure = (ch) => ch !== "{" /* BraceLeft */ &&\r\n            ch !== "}" /* BraceRight */ &&\r\n            ch !== CHAR_SP &&\r\n            ch !== CHAR_LF;\r\n        while ((ch = takeChar(scnr, closure))) {\r\n            identifiers += ch;\r\n        }\r\n        return identifiers;\r\n    }\r\n    function readLinkedModifier(scnr) {\r\n        let ch = \'\';\r\n        let name = \'\';\r\n        while ((ch = takeIdentifierChar(scnr))) {\r\n            name += ch;\r\n        }\r\n        return name;\r\n    }\r\n    function readLinkedRefer(scnr) {\r\n        const fn = (detect = false, buf) => {\r\n            const ch = scnr.currentChar();\r\n            if (ch === "{" /* BraceLeft */ ||\r\n                ch === "%" /* Modulo */ ||\r\n                ch === "@" /* LinkedAlias */ ||\r\n                ch === "|" /* Pipe */ ||\r\n                !ch) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_SP) {\r\n                return buf;\r\n            }\r\n            else if (ch === CHAR_LF) {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(detect, buf);\r\n            }\r\n            else {\r\n                buf += ch;\r\n                scnr.next();\r\n                return fn(true, buf);\r\n            }\r\n        };\r\n        return fn(false, \'\');\r\n    }\r\n    function readPlural(scnr) {\r\n        skipSpaces(scnr);\r\n        const plural = eat(scnr, "|" /* Pipe */);\r\n        skipSpaces(scnr);\r\n        return plural;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInPlaceholder(scnr, context) {\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case "{" /* BraceLeft */:\r\n                if (context.braceNest >= 1) {\r\n                    emitError(8 /* NOT_ALLOW_NEST_PLACEHOLDER */, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 2 /* BraceLeft */, "{" /* BraceLeft */);\r\n                skipSpaces(scnr);\r\n                context.braceNest++;\r\n                return token;\r\n            case "}" /* BraceRight */:\r\n                if (context.braceNest > 0 &&\r\n                    context.currentType === 2 /* BraceLeft */) {\r\n                    emitError(7 /* EMPTY_PLACEHOLDER */, currentPosition(), 0);\r\n                }\r\n                scnr.next();\r\n                token = getToken(context, 3 /* BraceRight */, "}" /* BraceRight */);\r\n                context.braceNest--;\r\n                context.braceNest > 0 && skipSpaces(scnr);\r\n                if (context.inLinked && context.braceNest === 0) {\r\n                    context.inLinked = false;\r\n                }\r\n                return token;\r\n            case "@" /* LinkedAlias */:\r\n                if (context.braceNest > 0) {\r\n                    emitError(6 /* UNTERMINATED_CLOSING_BRACE */, currentPosition(), 0);\r\n                }\r\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\r\n                context.braceNest = 0;\r\n                return token;\r\n            default:\r\n                let validNamedIdentifier = true;\r\n                let validListIdentifier = true;\r\n                let validLeteral = true;\r\n                if (isPluralStart(scnr)) {\r\n                    if (context.braceNest > 0) {\r\n                        emitError(6 /* UNTERMINATED_CLOSING_BRACE */, currentPosition(), 0);\r\n                    }\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (context.braceNest > 0 &&\r\n                    (context.currentType === 5 /* Named */ ||\r\n                        context.currentType === 6 /* List */ ||\r\n                        context.currentType === 7 /* Literal */)) {\r\n                    emitError(6 /* UNTERMINATED_CLOSING_BRACE */, currentPosition(), 0);\r\n                    context.braceNest = 0;\r\n                    return readToken(scnr, context);\r\n                }\r\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 5 /* Named */, readNamedIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\r\n                    token = getToken(context, 6 /* List */, readListIdentifier(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if ((validLeteral = isLiteralStart(scnr, context))) {\r\n                    token = getToken(context, 7 /* Literal */, readLiteral(scnr));\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                if (!validNamedIdentifier && !validListIdentifier && !validLeteral) {\r\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\r\n                    token = getToken(context, 13 /* InvalidPlace */, readInvalidIdentifier(scnr));\r\n                    emitError(1 /* INVALID_TOKEN_IN_PLACEHOLDER */, currentPosition(), 0, token.value);\r\n                    skipSpaces(scnr);\r\n                    return token;\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readTokenInLinked(scnr, context) {\r\n        const { currentType } = context;\r\n        let token = null;\r\n        const ch = scnr.currentChar();\r\n        if ((currentType === 8 /* LinkedAlias */ ||\r\n            currentType === 9 /* LinkedDot */ ||\r\n            currentType === 12 /* LinkedModifier */ ||\r\n            currentType === 10 /* LinkedDelimiter */) &&\r\n            (ch === CHAR_LF || ch === CHAR_SP)) {\r\n            emitError(9 /* INVALID_LINKED_FORMAT */, currentPosition(), 0);\r\n        }\r\n        switch (ch) {\r\n            case "@" /* LinkedAlias */:\r\n                scnr.next();\r\n                token = getToken(context, 8 /* LinkedAlias */, "@" /* LinkedAlias */);\r\n                context.inLinked = true;\r\n                return token;\r\n            case "." /* LinkedDot */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 9 /* LinkedDot */, "." /* LinkedDot */);\r\n            case ":" /* LinkedDelimiter */:\r\n                skipSpaces(scnr);\r\n                scnr.next();\r\n                return getToken(context, 10 /* LinkedDelimiter */, ":" /* LinkedDelimiter */);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (isLinkedDotStart(scnr, context) ||\r\n                    isLinkedDelimiterStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return readTokenInLinked(scnr, context);\r\n                }\r\n                if (isLinkedModifierStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    return getToken(context, 12 /* LinkedModifier */, readLinkedModifier(scnr));\r\n                }\r\n                if (isLinkedReferStart(scnr, context)) {\r\n                    skipSpaces(scnr);\r\n                    if (ch === "{" /* BraceLeft */) {\r\n                        // scan the placeholder\r\n                        return readTokenInPlaceholder(scnr, context) || token;\r\n                    }\r\n                    else {\r\n                        return getToken(context, 11 /* LinkedKey */, readLinkedRefer(scnr));\r\n                    }\r\n                }\r\n                if (currentType === 8 /* LinkedAlias */) {\r\n                    emitError(9 /* INVALID_LINKED_FORMAT */, currentPosition(), 0);\r\n                }\r\n                context.braceNest = 0;\r\n                context.inLinked = false;\r\n                return readToken(scnr, context);\r\n        }\r\n    }\r\n    // TODO: We need refactoring of token parsing ...\r\n    function readToken(scnr, context) {\r\n        let token = { type: 14 /* EOF */ };\r\n        if (context.braceNest > 0) {\r\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n        }\r\n        if (context.inLinked) {\r\n            return readTokenInLinked(scnr, context) || getEndToken(context);\r\n        }\r\n        const ch = scnr.currentChar();\r\n        switch (ch) {\r\n            case "{" /* BraceLeft */:\r\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\r\n            case "}" /* BraceRight */:\r\n                emitError(5 /* UNBALANCED_CLOSING_BRACE */, currentPosition(), 0);\r\n                scnr.next();\r\n                return getToken(context, 3 /* BraceRight */, "}" /* BraceRight */);\r\n            case "@" /* LinkedAlias */:\r\n                return readTokenInLinked(scnr, context) || getEndToken(context);\r\n            default:\r\n                if (isPluralStart(scnr)) {\r\n                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));\r\n                    // reset\r\n                    context.braceNest = 0;\r\n                    context.inLinked = false;\r\n                    return token;\r\n                }\r\n                if (isTextStart(scnr)) {\r\n                    return getToken(context, 0 /* Text */, readText(scnr));\r\n                }\r\n                if (ch === "%" /* Modulo */) {\r\n                    scnr.next();\r\n                    return getToken(context, 4 /* Modulo */, "%" /* Modulo */);\r\n                }\r\n                break;\r\n        }\r\n        return token;\r\n    }\r\n    function nextToken() {\r\n        const { currentType, offset, startLoc, endLoc } = _context;\r\n        _context.lastType = currentType;\r\n        _context.lastOffset = offset;\r\n        _context.lastStartLoc = startLoc;\r\n        _context.lastEndLoc = endLoc;\r\n        _context.offset = currentOffset();\r\n        _context.startLoc = currentPosition();\r\n        if (_scnr.currentChar() === EOF) {\r\n            return getToken(_context, 14 /* EOF */);\r\n        }\r\n        return readToken(_scnr, _context);\r\n    }\r\n    return {\r\n        nextToken,\r\n        currentOffset,\r\n        currentPosition,\r\n        context\r\n    };\r\n}\n\nconst ERROR_DOMAIN$1 = \'parser\';\r\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\r\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\r\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\r\n    switch (match) {\r\n        case `\\\\\\\\`:\r\n            return `\\\\`;\r\n        case `\\\\\\\'`:\r\n            return `\\\'`;\r\n        default: {\r\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\r\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\r\n                return String.fromCodePoint(codePoint);\r\n            }\r\n            // invalid ...\r\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\r\n            return \'�\';\r\n        }\r\n    }\r\n}\r\nfunction createParser(options = {}) {\r\n    const location = !options.location;\r\n    const { onError } = options;\r\n    function emitError(tokenzer, code, start, offset, ...args) {\r\n        const end = tokenzer.currentPosition();\r\n        end.offset += offset;\r\n        end.column += offset;\r\n        if (onError) {\r\n            const loc = createLocation(start, end);\r\n            const err = createCompileError(code, loc, {\r\n                domain: ERROR_DOMAIN$1,\r\n                args\r\n            });\r\n            onError(err);\r\n        }\r\n    }\r\n    function startNode(type, offset, loc) {\r\n        const node = {\r\n            type,\r\n            start: offset,\r\n            end: offset\r\n        };\r\n        if (location) {\r\n            node.loc = { start: loc, end: loc };\r\n        }\r\n        return node;\r\n    }\r\n    function endNode(node, offset, pos, type) {\r\n        node.end = offset;\r\n        if (type) {\r\n            node.type = type;\r\n        }\r\n        if (location && node.loc) {\r\n            node.loc.end = pos;\r\n        }\r\n    }\r\n    function parseText(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(3 /* Text */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseList(tokenizer, index) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(5 /* List */, offset, loc);\r\n        node.index = parseInt(index, 10);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseNamed(tokenizer, key) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(4 /* Named */, offset, loc);\r\n        node.key = key;\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLiteral(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\r\n        const node = startNode(9 /* Literal */, offset, loc);\r\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\r\n        tokenizer.nextToken(); // skip brach right\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinkedModifier(tokenizer) {\r\n        const token = tokenizer.nextToken();\r\n        const context = tokenizer.context();\r\n        // check token\r\n        if (token.value == null) {\r\n            emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n        }\r\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\r\n        const node = startNode(8 /* LinkedModifier */, offset, loc);\r\n        node.value = token.value || \'\';\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinkedKey(tokenizer, value) {\r\n        const context = tokenizer.context();\r\n        const node = startNode(7 /* LinkedKey */, context.offset, context.startLoc);\r\n        node.value = value;\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseLinked(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const linkedNode = startNode(6 /* Linked */, context.offset, context.startLoc);\r\n        let token = tokenizer.nextToken();\r\n        if (token.type === 9 /* LinkedDot */) {\r\n            linkedNode.modifier = parseLinkedModifier(tokenizer);\r\n            token = tokenizer.nextToken();\r\n        }\r\n        // asset check token\r\n        if (token.type !== 10 /* LinkedDelimiter */) {\r\n            emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n        }\r\n        token = tokenizer.nextToken();\r\n        // skip brace left\r\n        if (token.type === 2 /* BraceLeft */) {\r\n            token = tokenizer.nextToken();\r\n        }\r\n        switch (token.type) {\r\n            case 11 /* LinkedKey */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                }\r\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || \'\');\r\n                break;\r\n            case 5 /* Named */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                }\r\n                linkedNode.key = parseNamed(tokenizer, token.value || \'\');\r\n                break;\r\n            case 6 /* List */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                }\r\n                linkedNode.key = parseList(tokenizer, token.value || \'\');\r\n                break;\r\n            case 7 /* Literal */:\r\n                if (token.value == null) {\r\n                    emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                }\r\n                linkedNode.key = parseLiteral(tokenizer, token.value || \'\');\r\n                break;\r\n        }\r\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return linkedNode;\r\n    }\r\n    function parseMessage(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const startOffset = context.currentType === 1 /* Pipe */\r\n            ? tokenizer.currentOffset()\r\n            : context.offset;\r\n        const startLoc = context.currentType === 1 /* Pipe */\r\n            ? context.endLoc\r\n            : context.startLoc;\r\n        const node = startNode(2 /* Message */, startOffset, startLoc);\r\n        node.items = [];\r\n        do {\r\n            const token = tokenizer.nextToken();\r\n            switch (token.type) {\r\n                case 0 /* Text */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                    }\r\n                    node.items.push(parseText(tokenizer, token.value || \'\'));\r\n                    break;\r\n                case 6 /* List */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                    }\r\n                    node.items.push(parseList(tokenizer, token.value || \'\'));\r\n                    break;\r\n                case 5 /* Named */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                    }\r\n                    node.items.push(parseNamed(tokenizer, token.value || \'\'));\r\n                    break;\r\n                case 7 /* Literal */:\r\n                    if (token.value == null) {\r\n                        emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, token.type);\r\n                    }\r\n                    node.items.push(parseLiteral(tokenizer, token.value || \'\'));\r\n                    break;\r\n                case 8 /* LinkedAlias */:\r\n                    node.items.push(parseLinked(tokenizer));\r\n                    break;\r\n            }\r\n        } while (context.currentType !== 14 /* EOF */ &&\r\n            context.currentType !== 1 /* Pipe */);\r\n        // adjust message node loc\r\n        const endOffset = context.currentType === 1 /* Pipe */\r\n            ? context.lastOffset\r\n            : tokenizer.currentOffset();\r\n        const endLoc = context.currentType === 1 /* Pipe */\r\n            ? context.lastEndLoc\r\n            : tokenizer.currentPosition();\r\n        endNode(node, endOffset, endLoc);\r\n        return node;\r\n    }\r\n    function parsePlural(tokenizer, offset, loc, msgNode) {\r\n        const context = tokenizer.context();\r\n        let hasEmptyMessage = msgNode.items.length === 0;\r\n        const node = startNode(1 /* Plural */, offset, loc);\r\n        node.cases = [];\r\n        node.cases.push(msgNode);\r\n        do {\r\n            const msg = parseMessage(tokenizer);\r\n            if (!hasEmptyMessage) {\r\n                hasEmptyMessage = msg.items.length === 0;\r\n            }\r\n            node.cases.push(msg);\r\n        } while (context.currentType !== 14 /* EOF */);\r\n        if (hasEmptyMessage) {\r\n            emitError(tokenizer, 10 /* MUST_HAVE_MESSAGES_IN_PLURAL */, loc, 0);\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    function parseResource(tokenizer) {\r\n        const context = tokenizer.context();\r\n        const { offset, startLoc } = context;\r\n        const msgNode = parseMessage(tokenizer);\r\n        if (context.currentType === 14 /* EOF */) {\r\n            return msgNode;\r\n        }\r\n        else {\r\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\r\n        }\r\n    }\r\n    function parse(source) {\r\n        const tokenizer = createTokenizer(source, { ...options });\r\n        const context = tokenizer.context();\r\n        const node = startNode(0 /* Resource */, context.offset, context.startLoc);\r\n        if (location && node.loc) {\r\n            node.loc.source = source;\r\n        }\r\n        node.body = parseResource(tokenizer);\r\n        // assert wheather achieved to EOF\r\n        if (context.currentType !== 14 /* EOF */) {\r\n            emitError(tokenizer, 11 /* UNEXPECTED_LEXICAL_ANALYSIS */, context.lastStartLoc, 0, context.currentType);\r\n        }\r\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\r\n        return node;\r\n    }\r\n    return { parse };\r\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\r\n) {\r\n    const _context = {\r\n        ast,\r\n        helpers: new Set()\r\n    };\r\n    const context = () => _context;\r\n    const helper = (name) => {\r\n        _context.helpers.add(name);\r\n        return name;\r\n    };\r\n    return { context, helper };\r\n}\r\nfunction traverseNodes(nodes, transformer) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        traverseNode(nodes[i], transformer);\r\n    }\r\n}\r\nfunction traverseNode(node, transformer) {\r\n    // TODO: if we need pre-hook of transform, should be implemeted to here\r\n    switch (node.type) {\r\n        case 1 /* Plural */:\r\n            traverseNodes(node.cases, transformer);\r\n            transformer.helper("plural" /* PLURAL */);\r\n            break;\r\n        case 2 /* Message */:\r\n            traverseNodes(node.items, transformer);\r\n            break;\r\n        case 6 /* Linked */:\r\n            const linked = node;\r\n            traverseNode(linked.key, transformer);\r\n            transformer.helper("linked" /* LINKED */);\r\n            break;\r\n        case 5 /* List */:\r\n            transformer.helper("interpolate" /* INTERPOLATE */);\r\n            transformer.helper("list" /* LIST */);\r\n            break;\r\n        case 4 /* Named */:\r\n            transformer.helper("interpolate" /* INTERPOLATE */);\r\n            transformer.helper("named" /* NAMED */);\r\n            break;\r\n    }\r\n    // TODO: if we need post-hook of transform, should be implemeted to here\r\n}\r\n// transform AST\r\nfunction transform(ast, options = {} // eslint-disable-line\r\n) {\r\n    const transformer = createTransformer(ast);\r\n    transformer.helper("normalize" /* NORMALIZE */);\r\n    // traverse\r\n    ast.body && traverseNode(ast.body, transformer);\r\n    // set meta information\r\n    const context = transformer.context();\r\n    ast.helpers = [...context.helpers];\r\n}\n\nfunction createCodeGenerator(ast, options) {\r\n    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;\r\n    const _context = {\r\n        source: ast.loc.source,\r\n        filename,\r\n        code: \'\',\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        map: undefined,\r\n        breakLineCode,\r\n        needIndent: _needIndent,\r\n        indentLevel: 0\r\n    };\r\n    const context = () => _context;\r\n    function push(code, node) {\r\n        _context.code += code;\r\n    }\r\n    function _newline(n, withBreakLine = true) {\r\n        const _breakLineCode = withBreakLine ? breakLineCode : \'\';\r\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\r\n    }\r\n    function indent(withNewLine = true) {\r\n        const level = ++_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function deindent(withNewLine = true) {\r\n        const level = --_context.indentLevel;\r\n        withNewLine && _newline(level);\r\n    }\r\n    function newline() {\r\n        _newline(_context.indentLevel);\r\n    }\r\n    const helper = (key) => `_${key}`;\r\n    const needIndent = () => _context.needIndent;\r\n    return {\r\n        context,\r\n        push,\r\n        indent,\r\n        deindent,\r\n        newline,\r\n        helper,\r\n        needIndent\r\n    };\r\n}\r\nfunction generateLinkedNode(generator, node) {\r\n    const { helper } = generator;\r\n    generator.push(`${helper("linked" /* LINKED */)}(`);\r\n    generateNode(generator, node.key);\r\n    if (node.modifier) {\r\n        generator.push(`, `);\r\n        generateNode(generator, node.modifier);\r\n    }\r\n    generator.push(`)`);\r\n}\r\nfunction generateMessageNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    generator.push(`${helper("normalize" /* NORMALIZE */)}([`);\r\n    generator.indent(needIndent());\r\n    const length = node.items.length;\r\n    for (let i = 0; i < length; i++) {\r\n        generateNode(generator, node.items[i]);\r\n        if (i === length - 1) {\r\n            break;\r\n        }\r\n        generator.push(\', \');\r\n    }\r\n    generator.deindent(needIndent());\r\n    generator.push(\'])\');\r\n}\r\nfunction generatePluralNode(generator, node) {\r\n    const { helper, needIndent } = generator;\r\n    if (node.cases.length > 1) {\r\n        generator.push(`${helper("plural" /* PLURAL */)}([`);\r\n        generator.indent(needIndent());\r\n        const length = node.cases.length;\r\n        for (let i = 0; i < length; i++) {\r\n            generateNode(generator, node.cases[i]);\r\n            if (i === length - 1) {\r\n                break;\r\n            }\r\n            generator.push(\', \');\r\n        }\r\n        generator.deindent(needIndent());\r\n        generator.push(`])`);\r\n    }\r\n}\r\nfunction generateResource(generator, node) {\r\n    if (node.body) {\r\n        generateNode(generator, node.body);\r\n    }\r\n    else {\r\n        generator.push(\'null\');\r\n    }\r\n}\r\nfunction generateNode(generator, node) {\r\n    const { helper } = generator;\r\n    switch (node.type) {\r\n        case 0 /* Resource */:\r\n            generateResource(generator, node);\r\n            break;\r\n        case 1 /* Plural */:\r\n            generatePluralNode(generator, node);\r\n            break;\r\n        case 2 /* Message */:\r\n            generateMessageNode(generator, node);\r\n            break;\r\n        case 6 /* Linked */:\r\n            generateLinkedNode(generator, node);\r\n            break;\r\n        case 8 /* LinkedModifier */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 7 /* LinkedKey */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 5 /* List */:\r\n            generator.push(`${helper("interpolate" /* INTERPOLATE */)}(${helper("list" /* LIST */)}(${node.index}))`, node);\r\n            break;\r\n        case 4 /* Named */:\r\n            generator.push(`${helper("interpolate" /* INTERPOLATE */)}(${helper("named" /* NAMED */)}(${JSON.stringify(node.key)}))`, node);\r\n            break;\r\n        case 9 /* Literal */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        case 3 /* Text */:\r\n            generator.push(JSON.stringify(node.value), node);\r\n            break;\r\n        default:\r\n            if ((false)) {}\r\n    }\r\n}\r\n// generate code from AST\r\nconst generate = (ast, options = {} // eslint-disable-line\r\n) => {\r\n    const mode = Object(shared_esm_bundler["n" /* isString */])(options.mode) ? options.mode : \'normal\';\r\n    const filename = Object(shared_esm_bundler["n" /* isString */])(options.filename)\r\n        ? options.filename\r\n        : \'message.intl\';\r\n    const sourceMap = !!options.sourceMap;\r\n    // prettier-ignore\r\n    const breakLineCode = options.breakLineCode != null\r\n        ? options.breakLineCode\r\n        : mode === \'arrow\'\r\n            ? \';\'\r\n            : \'\\n\';\r\n    const needIndent = options.needIndent ? options.needIndent : mode !== \'arrow\';\r\n    const helpers = ast.helpers || [];\r\n    const generator = createCodeGenerator(ast, {\r\n        mode,\r\n        filename,\r\n        sourceMap,\r\n        breakLineCode,\r\n        needIndent\r\n    });\r\n    generator.push(mode === \'normal\' ? `function __msg__ (ctx) {` : `(ctx) => {`);\r\n    generator.indent(needIndent);\r\n    if (helpers.length > 0) {\r\n        generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(\', \')} } = ctx`);\r\n        generator.newline();\r\n    }\r\n    generator.push(`return `);\r\n    generateNode(generator, ast);\r\n    generator.deindent(needIndent);\r\n    generator.push(`}`);\r\n    const { code, map } = generator.context();\r\n    return {\r\n        ast,\r\n        code,\r\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\r\n    };\r\n};\n\nfunction baseCompile(source, options = {}) {\r\n    // parse source codes\r\n    const parser = createParser({ ...options });\r\n    const ast = parser.parse(source);\r\n    // transform ASTs\r\n    transform(ast, { ...options });\r\n    // generate javascript codes\r\n    return generate(ast, { ...options });\r\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/@intlify/core-base/dist/core-base.esm-bundler.js\n/*!\n  * @intlify/core-base v9.0.0-beta.14\n  * (c) 2020 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n\n\n\n\n\n\n\n/** @internal */\r\nconst warnMessages = {\r\n    [0 /* NOT_FOUND_KEY */]: `Not found \'{key}\' key in \'{locale}\' locale messages.`,\r\n    [1 /* FALLBACK_TO_TRANSLATE */]: `Fall back to translate \'{key}\' key with \'{target}\' locale.`,\r\n    [2 /* CANNOT_FORMAT_NUMBER */]: `Cannot format a number value due to not supported Intl.NumberFormat.`,\r\n    [3 /* FALLBACK_TO_NUMBER_FORMAT */]: `Fall back to number format \'{key}\' key with \'{target}\' locale.`,\r\n    [4 /* CANNOT_FORMAT_DATE */]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,\r\n    [5 /* FALLBACK_TO_DATE_FORMAT */]: `Fall back to datetime format \'{key}\' key with \'{target}\' locale.`\r\n};\r\nfunction getWarnMessage(code, ...args) {\r\n    return Object(shared_esm_bundler["b" /* format */])(warnMessages[code], ...args);\r\n}\n\nconst NOT_REOSLVED = -1;\r\nconst MISSING_RESOLVE_VALUE = \'\';\r\nfunction getDefaultLinkedModifiers() {\r\n    return {\r\n        upper: (val) => (Object(shared_esm_bundler["n" /* isString */])(val) ? val.toUpperCase() : val),\r\n        lower: (val) => (Object(shared_esm_bundler["n" /* isString */])(val) ? val.toLowerCase() : val),\r\n        // prettier-ignore\r\n        capitalize: (val) => (Object(shared_esm_bundler["n" /* isString */])(val)\r\n            ? `${val.charAt(0).toLocaleUpperCase()}${val.substr(1)}`\r\n            : val)\r\n    };\r\n}\r\nlet _compiler;\r\nfunction registerMessageCompiler(compiler) {\r\n    _compiler = compiler;\r\n}\r\nfunction createCoreContext(options = {}) {\r\n    // setup options\r\n    const locale = Object(shared_esm_bundler["n" /* isString */])(options.locale) ? options.locale : \'en-US\';\r\n    const fallbackLocale = Object(shared_esm_bundler["e" /* isArray */])(options.fallbackLocale) ||\r\n        Object(shared_esm_bundler["l" /* isPlainObject */])(options.fallbackLocale) ||\r\n        Object(shared_esm_bundler["n" /* isString */])(options.fallbackLocale) ||\r\n        options.fallbackLocale === false\r\n        ? options.fallbackLocale\r\n        : locale;\r\n    const messages = Object(shared_esm_bundler["l" /* isPlainObject */])(options.messages)\r\n        ? options.messages\r\n        : { [locale]: {} };\r\n    const datetimeFormats = Object(shared_esm_bundler["l" /* isPlainObject */])(options.datetimeFormats)\r\n        ? options.datetimeFormats\r\n        : { [locale]: {} };\r\n    const numberFormats = Object(shared_esm_bundler["l" /* isPlainObject */])(options.numberFormats)\r\n        ? options.numberFormats\r\n        : { [locale]: {} };\r\n    const modifiers = Object.assign({}, options.modifiers || {}, getDefaultLinkedModifiers());\r\n    const pluralRules = options.pluralRules || {};\r\n    const missing = Object(shared_esm_bundler["i" /* isFunction */])(options.missing) ? options.missing : null;\r\n    const missingWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.missingWarn) || Object(shared_esm_bundler["m" /* isRegExp */])(options.missingWarn)\r\n        ? options.missingWarn\r\n        : true;\r\n    const fallbackWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.fallbackWarn) || Object(shared_esm_bundler["m" /* isRegExp */])(options.fallbackWarn)\r\n        ? options.fallbackWarn\r\n        : true;\r\n    const fallbackFormat = !!options.fallbackFormat;\r\n    const unresolving = !!options.unresolving;\r\n    const postTranslation = Object(shared_esm_bundler["i" /* isFunction */])(options.postTranslation)\r\n        ? options.postTranslation\r\n        : null;\r\n    const processor = Object(shared_esm_bundler["l" /* isPlainObject */])(options.processor) ? options.processor : null;\r\n    const warnHtmlMessage = Object(shared_esm_bundler["f" /* isBoolean */])(options.warnHtmlMessage)\r\n        ? options.warnHtmlMessage\r\n        : true;\r\n    const escapeParameter = !!options.escapeParameter;\r\n    const messageCompiler = Object(shared_esm_bundler["i" /* isFunction */])(options.messageCompiler)\r\n        ? options.messageCompiler\r\n        : _compiler;\r\n    const onWarn = Object(shared_esm_bundler["i" /* isFunction */])(options.onWarn) ? options.onWarn : shared_esm_bundler["q" /* warn */];\r\n    // setup internal options\r\n    const internalOptions = options;\r\n    const __datetimeFormatters = Object(shared_esm_bundler["k" /* isObject */])(internalOptions.__datetimeFormatters)\r\n        ? internalOptions.__datetimeFormatters\r\n        : new Map();\r\n    const __numberFormatters = Object(shared_esm_bundler["k" /* isObject */])(internalOptions.__numberFormatters)\r\n        ? internalOptions.__numberFormatters\r\n        : new Map();\r\n    const context = {\r\n        locale,\r\n        fallbackLocale,\r\n        messages,\r\n        datetimeFormats,\r\n        numberFormats,\r\n        modifiers,\r\n        pluralRules,\r\n        missing,\r\n        missingWarn,\r\n        fallbackWarn,\r\n        fallbackFormat,\r\n        unresolving,\r\n        postTranslation,\r\n        processor,\r\n        warnHtmlMessage,\r\n        escapeParameter,\r\n        messageCompiler,\r\n        onWarn,\r\n        __datetimeFormatters,\r\n        __numberFormatters\r\n    };\r\n    // for vue-devtools timeline event\r\n    if ((false)) {}\r\n    return context;\r\n}\r\n/** @internal */\r\nfunction isTranslateFallbackWarn(fallback, key) {\r\n    return fallback instanceof RegExp ? fallback.test(key) : fallback;\r\n}\r\n/** @internal */\r\nfunction isTranslateMissingWarn(missing, key) {\r\n    return missing instanceof RegExp ? missing.test(key) : missing;\r\n}\r\n/** @internal */\r\nfunction handleMissing(context, key, locale, missingWarn, type) {\r\n    const { missing, onWarn } = context;\r\n    // for vue-devtools timeline event\r\n    if ((false)) {}\r\n    if (missing !== null) {\r\n        const ret = missing(context, locale, key, type);\r\n        return Object(shared_esm_bundler["n" /* isString */])(ret) ? ret : key;\r\n    }\r\n    else {\r\n        if (false) {}\r\n        return key;\r\n    }\r\n}\r\n/** @internal */\r\nfunction getLocaleChain(ctx, fallback, start = \'\') {\r\n    const context = ctx;\r\n    if (start === \'\') {\r\n        return [];\r\n    }\r\n    if (!context.__localeChainCache) {\r\n        context.__localeChainCache = new Map();\r\n    }\r\n    let chain = context.__localeChainCache.get(start);\r\n    if (!chain) {\r\n        chain = [];\r\n        // first block defined by start\r\n        let block = [start];\r\n        // while any intervening block found\r\n        while (Object(shared_esm_bundler["e" /* isArray */])(block)) {\r\n            block = appendBlockToChain(chain, block, fallback);\r\n        }\r\n        // prettier-ignore\r\n        // last block defined by default\r\n        const defaults = Object(shared_esm_bundler["e" /* isArray */])(fallback)\r\n            ? fallback\r\n            : Object(shared_esm_bundler["l" /* isPlainObject */])(fallback)\r\n                ? fallback[\'default\']\r\n                    ? fallback[\'default\']\r\n                    : null\r\n                : fallback;\r\n        // convert defaults to array\r\n        block = Object(shared_esm_bundler["n" /* isString */])(defaults) ? [defaults] : defaults;\r\n        if (Object(shared_esm_bundler["e" /* isArray */])(block)) {\r\n            appendBlockToChain(chain, block, false);\r\n        }\r\n        context.__localeChainCache.set(start, chain);\r\n    }\r\n    return chain;\r\n}\r\nfunction appendBlockToChain(chain, block, blocks) {\r\n    let follow = true;\r\n    for (let i = 0; i < block.length && Object(shared_esm_bundler["f" /* isBoolean */])(follow); i++) {\r\n        const locale = block[i];\r\n        if (Object(shared_esm_bundler["n" /* isString */])(locale)) {\r\n            follow = appendLocaleToChain(chain, block[i], blocks);\r\n        }\r\n    }\r\n    return follow;\r\n}\r\nfunction appendLocaleToChain(chain, locale, blocks) {\r\n    let follow;\r\n    const tokens = locale.split(\'-\');\r\n    do {\r\n        const target = tokens.join(\'-\');\r\n        follow = appendItemToChain(chain, target, blocks);\r\n        tokens.splice(-1, 1);\r\n    } while (tokens.length && follow === true);\r\n    return follow;\r\n}\r\nfunction appendItemToChain(chain, target, blocks) {\r\n    let follow = false;\r\n    if (!chain.includes(target)) {\r\n        follow = true;\r\n        if (target) {\r\n            follow = target[target.length - 1] !== \'!\';\r\n            const locale = target.replace(/!/g, \'\');\r\n            chain.push(locale);\r\n            if ((Object(shared_esm_bundler["e" /* isArray */])(blocks) || Object(shared_esm_bundler["l" /* isPlainObject */])(blocks)) &&\r\n                blocks[locale] // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            ) {\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                follow = blocks[locale];\r\n            }\r\n        }\r\n    }\r\n    return follow;\r\n}\r\n/** @internal */\r\nfunction updateFallbackLocale(ctx, locale, fallback) {\r\n    const context = ctx;\r\n    context.__localeChainCache = new Map();\r\n    getLocaleChain(ctx, fallback, locale);\r\n}\n\nconst RE_HTML_TAG = /<\\/?[\\w\\s="/.\':;#-\\/]+>/;\r\nconst WARN_MESSAGE = `Detected HTML in \'{source}\' message. Recommend not using HTML messages to avoid XSS.`;\r\nfunction checkHtmlMessage(source, options) {\r\n    const warnHtmlMessage = Object(shared_esm_bundler["f" /* isBoolean */])(options.warnHtmlMessage)\r\n        ? options.warnHtmlMessage\r\n        : true;\r\n    if (warnHtmlMessage && RE_HTML_TAG.test(source)) {\r\n        Object(shared_esm_bundler["q" /* warn */])(Object(shared_esm_bundler["b" /* format */])(WARN_MESSAGE, { source }));\r\n    }\r\n}\r\nconst defaultOnCacheKey = (source) => source;\r\nlet compileCache = Object.create(null);\r\nfunction clearCompileCache() {\r\n    compileCache = Object.create(null);\r\n}\r\nfunction compileToFunction(source, options = {}) {\r\n    {\r\n        // check HTML message\r\n        ( false) && false;\r\n        // check caches\r\n        const onCacheKey = options.onCacheKey || defaultOnCacheKey;\r\n        const key = onCacheKey(source);\r\n        const cached = compileCache[key];\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n        // compile error detecting\r\n        let occured = false;\r\n        const onError = options.onError || defaultOnError;\r\n        options.onError = (err) => {\r\n            occured = true;\r\n            onError(err);\r\n        };\r\n        // compile\r\n        const { code } = baseCompile(source, options);\r\n        // evaluate function\r\n        const msg = new Function(`return ${code}`)();\r\n        // if occured compile error, don\'t cache\r\n        return !occured ? (compileCache[key] = msg) : msg;\r\n    }\r\n}\n\nfunction createCoreError(code) {\r\n    return createCompileError(code, null, ( false) ? undefined : undefined);\r\n}\r\n/** @internal */\r\nconst core_base_esm_bundler_errorMessages = {\r\n    [12 /* INVALID_ARGUMENT */]: \'Invalid arguments\',\r\n    [13 /* INVALID_DATE_ARGUMENT */]: \'The date provided is an invalid Date object.\' +\r\n        \'Make sure your Date represents a valid date.\',\r\n    [14 /* INVALID_ISO_DATE_ARGUMENT */]: \'The argument provided is not a valid ISO date string\'\r\n};\n\nconst NOOP_MESSAGE_FUNCTION = () => \'\';\r\nconst isMessageFunction = (val) => Object(shared_esm_bundler["i" /* isFunction */])(val);\r\n// implementationo of `translate` function\r\nfunction translate(context, ...args) {\r\n    const { fallbackFormat, postTranslation, unresolving, fallbackLocale } = context;\r\n    const [key, options] = parseTranslateArgs(...args);\r\n    const missingWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.missingWarn)\r\n        ? options.missingWarn\r\n        : context.missingWarn;\r\n    const fallbackWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.fallbackWarn)\r\n        ? options.fallbackWarn\r\n        : context.fallbackWarn;\r\n    const escapeParameter = Object(shared_esm_bundler["f" /* isBoolean */])(options.escapeParameter)\r\n        ? options.escapeParameter\r\n        : context.escapeParameter;\r\n    // prettier-ignore\r\n    const defaultMsgOrKey = Object(shared_esm_bundler["n" /* isString */])(options.default) || Object(shared_esm_bundler["f" /* isBoolean */])(options.default) // default by function option\r\n        ? !Object(shared_esm_bundler["f" /* isBoolean */])(options.default)\r\n            ? options.default\r\n            : key\r\n        : fallbackFormat // default by `fallbackFormat` option\r\n            ? key\r\n            : \'\';\r\n    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== \'\';\r\n    const locale = Object(shared_esm_bundler["n" /* isString */])(options.locale) ? options.locale : context.locale;\r\n    // escape params\r\n    escapeParameter && escapeParams(options);\r\n    // resolve message format\r\n    // eslint-disable-next-line prefer-const\r\n    let [format, targetLocale, message] = resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn);\r\n    // if you use default message, set it as message format!\r\n    let cacheBaseKey = key;\r\n    if (!(Object(shared_esm_bundler["n" /* isString */])(format) || isMessageFunction(format))) {\r\n        if (enableDefaultMsg) {\r\n            format = defaultMsgOrKey;\r\n            cacheBaseKey = format;\r\n        }\r\n    }\r\n    // checking message format and target locale\r\n    if (!(Object(shared_esm_bundler["n" /* isString */])(format) || isMessageFunction(format)) ||\r\n        !Object(shared_esm_bundler["n" /* isString */])(targetLocale)) {\r\n        return unresolving ? NOT_REOSLVED : key;\r\n    }\r\n    if (false) {}\r\n    // setup compile error detecting\r\n    let occured = false;\r\n    const errorDetector = () => {\r\n        occured = true;\r\n    };\r\n    // compile message format\r\n    const msg = compileMessasgeFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector);\r\n    // if occured compile error, return the message format\r\n    if (occured) {\r\n        return format;\r\n    }\r\n    // evaluate message with context\r\n    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);\r\n    const msgContext = createMessageContext(ctxOptions);\r\n    const messaged = evaluateMessage(context, msg, msgContext);\r\n    // if use post translation option, procee it with handler\r\n    return postTranslation ? postTranslation(messaged) : messaged;\r\n}\r\nfunction escapeParams(options) {\r\n    if (Object(shared_esm_bundler["e" /* isArray */])(options.list)) {\r\n        options.list = options.list.map(item => Object(shared_esm_bundler["n" /* isString */])(item) ? Object(shared_esm_bundler["a" /* escapeHtml */])(item) : item);\r\n    }\r\n    else if (Object(shared_esm_bundler["k" /* isObject */])(options.named)) {\r\n        Object.keys(options.named).forEach(key => {\r\n            if (Object(shared_esm_bundler["n" /* isString */])(options.named[key])) {\r\n                options.named[key] = Object(shared_esm_bundler["a" /* escapeHtml */])(options.named[key]);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {\r\n    const { messages, onWarn } = context;\r\n    const locales = getLocaleChain(context, fallbackLocale, locale);\r\n    let message = {};\r\n    let targetLocale;\r\n    let format = null;\r\n    let from = locale;\r\n    let to = null;\r\n    const type = \'translate\';\r\n    for (let i = 0; i < locales.length; i++) {\r\n        targetLocale = to = locales[i];\r\n        if (false) {}\r\n        // for vue-devtools timeline event\r\n        if (false) {}\r\n        message =\r\n            messages[targetLocale] || {};\r\n        // for vue-devtools timeline event\r\n        let start = null;\r\n        let startTag;\r\n        let endTag;\r\n        if (false) {}\r\n        if ((format = resolveValue(message, key)) === null) {\r\n            // if null, resolve with object key path\r\n            format = message[key]; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n        }\r\n        // for vue-devtools timeline event\r\n        if (false) {}\r\n        if (Object(shared_esm_bundler["n" /* isString */])(format) || Object(shared_esm_bundler["i" /* isFunction */])(format))\r\n            break;\r\n        const missingRet = handleMissing(context, key, targetLocale, missingWarn, type);\r\n        if (missingRet !== key) {\r\n            format = missingRet;\r\n        }\r\n        from = to;\r\n    }\r\n    return [format, targetLocale, message];\r\n}\r\nfunction compileMessasgeFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) {\r\n    const { messageCompiler, warnHtmlMessage } = context;\r\n    if (isMessageFunction(format)) {\r\n        const msg = format;\r\n        msg.locale = msg.locale || targetLocale;\r\n        msg.key = msg.key || key;\r\n        return msg;\r\n    }\r\n    // for vue-devtools timeline event\r\n    let start = null;\r\n    let startTag;\r\n    let endTag;\r\n    if (false) {}\r\n    const msg = messageCompiler(format, getCompileOptions(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, errorDetector));\r\n    // for vue-devtools timeline event\r\n    if (false) {}\r\n    msg.locale = targetLocale;\r\n    msg.key = key;\r\n    msg.source = format;\r\n    return msg;\r\n}\r\nfunction evaluateMessage(context, msg, msgCtx) {\r\n    // for vue-devtools timeline event\r\n    let start = null;\r\n    let startTag;\r\n    let endTag;\r\n    if (false) {}\r\n    const messaged = msg(msgCtx);\r\n    // for vue-devtools timeline event\r\n    if (false) {}\r\n    return messaged;\r\n}\r\n/** @internal */\r\nfunction parseTranslateArgs(...args) {\r\n    const [arg1, arg2, arg3] = args;\r\n    const options = {};\r\n    if (!Object(shared_esm_bundler["n" /* isString */])(arg1)) {\r\n        throw createCoreError(12 /* INVALID_ARGUMENT */);\r\n    }\r\n    const key = arg1;\r\n    if (Object(shared_esm_bundler["j" /* isNumber */])(arg2)) {\r\n        options.plural = arg2;\r\n    }\r\n    else if (Object(shared_esm_bundler["n" /* isString */])(arg2)) {\r\n        options.default = arg2;\r\n    }\r\n    else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg2) && !Object(shared_esm_bundler["h" /* isEmptyObject */])(arg2)) {\r\n        options.named = arg2;\r\n    }\r\n    else if (Object(shared_esm_bundler["e" /* isArray */])(arg2)) {\r\n        options.list = arg2;\r\n    }\r\n    if (Object(shared_esm_bundler["j" /* isNumber */])(arg3)) {\r\n        options.plural = arg3;\r\n    }\r\n    else if (Object(shared_esm_bundler["n" /* isString */])(arg3)) {\r\n        options.default = arg3;\r\n    }\r\n    else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg3)) {\r\n        Object.assign(options, arg3);\r\n    }\r\n    return [key, options];\r\n}\r\nfunction getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {\r\n    return {\r\n        warnHtmlMessage,\r\n        onError: (err) => {\r\n            errorDetector && errorDetector(err);\r\n            if ((false)) {}\r\n            else {\r\n                throw err;\r\n            }\r\n        },\r\n        onCacheKey: (source) => Object(shared_esm_bundler["c" /* generateFormatCacheKey */])(locale, key, source)\r\n    };\r\n}\r\nfunction getMessageContextOptions(context, locale, message, options) {\r\n    const { modifiers, pluralRules } = context;\r\n    const resolveMessage = (key) => {\r\n        const val = resolveValue(message, key);\r\n        if (Object(shared_esm_bundler["n" /* isString */])(val)) {\r\n            let occured = false;\r\n            const errorDetector = () => {\r\n                occured = true;\r\n            };\r\n            const msg = compileMessasgeFormat(context, key, locale, val, key, errorDetector);\r\n            return !occured\r\n                ? msg\r\n                : NOOP_MESSAGE_FUNCTION;\r\n        }\r\n        else if (isMessageFunction(val)) {\r\n            return val;\r\n        }\r\n        else {\r\n            // TODO: should be implemented warning message\r\n            return NOOP_MESSAGE_FUNCTION;\r\n        }\r\n    };\r\n    const ctxOptions = {\r\n        locale,\r\n        modifiers,\r\n        pluralRules,\r\n        messages: resolveMessage\r\n    };\r\n    if (context.processor) {\r\n        ctxOptions.processor = context.processor;\r\n    }\r\n    if (options.list) {\r\n        ctxOptions.list = options.list;\r\n    }\r\n    if (options.named) {\r\n        ctxOptions.named = options.named;\r\n    }\r\n    if (Object(shared_esm_bundler["j" /* isNumber */])(options.plural)) {\r\n        ctxOptions.pluralIndex = options.plural;\r\n    }\r\n    return ctxOptions;\r\n}\n\nconst intlDefined = typeof Intl !== \'undefined\';\r\nconst Availabilities = {\r\n    dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== \'undefined\',\r\n    numberFormat: intlDefined && typeof Intl.NumberFormat !== \'undefined\'\r\n};\n\n// implementation of `datetime` function\r\nfunction datetime(context, ...args) {\r\n    const { datetimeFormats, unresolving, fallbackLocale, onWarn } = context;\r\n    const { __datetimeFormatters } = context;\r\n    if (false) {}\r\n    const [key, value, options, orverrides] = parseDateTimeArgs(...args);\r\n    const missingWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.missingWarn)\r\n        ? options.missingWarn\r\n        : context.missingWarn;\r\n    const fallbackWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.fallbackWarn)\r\n        ? options.fallbackWarn\r\n        : context.fallbackWarn;\r\n    const part = !!options.part;\r\n    const locale = Object(shared_esm_bundler["n" /* isString */])(options.locale) ? options.locale : context.locale;\r\n    const locales = getLocaleChain(context, fallbackLocale, locale);\r\n    if (!Object(shared_esm_bundler["n" /* isString */])(key) || key === \'\') {\r\n        return new Intl.DateTimeFormat(locale).format(value);\r\n    }\r\n    // resolve format\r\n    let datetimeFormat = {};\r\n    let targetLocale;\r\n    let format = null;\r\n    let from = locale;\r\n    let to = null;\r\n    const type = \'datetime format\';\r\n    for (let i = 0; i < locales.length; i++) {\r\n        targetLocale = to = locales[i];\r\n        if (false) {}\r\n        // for vue-devtools timeline event\r\n        if (false) {}\r\n        datetimeFormat =\r\n            datetimeFormats[targetLocale] || {};\r\n        format = datetimeFormat[key];\r\n        if (Object(shared_esm_bundler["l" /* isPlainObject */])(format))\r\n            break;\r\n        handleMissing(context, key, targetLocale, missingWarn, type);\r\n        from = to;\r\n    }\r\n    // checking format and target locale\r\n    if (!Object(shared_esm_bundler["l" /* isPlainObject */])(format) || !Object(shared_esm_bundler["n" /* isString */])(targetLocale)) {\r\n        return unresolving ? NOT_REOSLVED : key;\r\n    }\r\n    let id = `${targetLocale}__${key}`;\r\n    if (!Object(shared_esm_bundler["h" /* isEmptyObject */])(orverrides)) {\r\n        id = `${id}__${JSON.stringify(orverrides)}`;\r\n    }\r\n    let formatter = __datetimeFormatters.get(id);\r\n    if (!formatter) {\r\n        formatter = new Intl.DateTimeFormat(targetLocale, Object.assign({}, format, orverrides));\r\n        __datetimeFormatters.set(id, formatter);\r\n    }\r\n    return !part ? formatter.format(value) : formatter.formatToParts(value);\r\n}\r\n/** @internal */\r\nfunction parseDateTimeArgs(...args) {\r\n    const [arg1, arg2, arg3, arg4] = args;\r\n    let options = {};\r\n    let orverrides = {};\r\n    let value;\r\n    if (Object(shared_esm_bundler["n" /* isString */])(arg1)) {\r\n        // Only allow ISO strings - other date formats are often supported,\r\n        // but may cause different results in different browsers.\r\n        if (!/\\d{4}-\\d{2}-\\d{2}(T.*)?/.test(arg1)) {\r\n            throw createCoreError(14 /* INVALID_ISO_DATE_ARGUMENT */);\r\n        }\r\n        value = new Date(arg1);\r\n        try {\r\n            // This will fail if the date is not valid\r\n            value.toISOString();\r\n        }\r\n        catch (e) {\r\n            throw createCoreError(14 /* INVALID_ISO_DATE_ARGUMENT */);\r\n        }\r\n    }\r\n    else if (Object(shared_esm_bundler["g" /* isDate */])(arg1)) {\r\n        if (isNaN(arg1.getTime())) {\r\n            throw createCoreError(13 /* INVALID_DATE_ARGUMENT */);\r\n        }\r\n        value = arg1;\r\n    }\r\n    else if (Object(shared_esm_bundler["j" /* isNumber */])(arg1)) {\r\n        value = arg1;\r\n    }\r\n    else {\r\n        throw createCoreError(12 /* INVALID_ARGUMENT */);\r\n    }\r\n    if (Object(shared_esm_bundler["n" /* isString */])(arg2)) {\r\n        options.key = arg2;\r\n    }\r\n    else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg2)) {\r\n        options = arg2;\r\n    }\r\n    if (Object(shared_esm_bundler["n" /* isString */])(arg3)) {\r\n        options.locale = arg3;\r\n    }\r\n    else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg3)) {\r\n        orverrides = arg3;\r\n    }\r\n    if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg4)) {\r\n        orverrides = arg4;\r\n    }\r\n    return [options.key || \'\', value, options, orverrides];\r\n}\r\n/** @internal */\r\nfunction clearDateTimeFormat(ctx, locale, format) {\r\n    const context = ctx;\r\n    for (const key in format) {\r\n        const id = `${locale}__${key}`;\r\n        if (!context.__datetimeFormatters.has(id)) {\r\n            continue;\r\n        }\r\n        context.__datetimeFormatters.delete(id);\r\n    }\r\n}\n\n// implementation of `number` function\r\nfunction number(context, ...args) {\r\n    const { numberFormats, unresolving, fallbackLocale, onWarn } = context;\r\n    const { __numberFormatters } = context;\r\n    if (false) {}\r\n    const [key, value, options, orverrides] = parseNumberArgs(...args);\r\n    const missingWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.missingWarn)\r\n        ? options.missingWarn\r\n        : context.missingWarn;\r\n    const fallbackWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.fallbackWarn)\r\n        ? options.fallbackWarn\r\n        : context.fallbackWarn;\r\n    const part = !!options.part;\r\n    const locale = Object(shared_esm_bundler["n" /* isString */])(options.locale) ? options.locale : context.locale;\r\n    const locales = getLocaleChain(context, fallbackLocale, locale);\r\n    if (!Object(shared_esm_bundler["n" /* isString */])(key) || key === \'\') {\r\n        return new Intl.NumberFormat(locale).format(value);\r\n    }\r\n    // resolve format\r\n    let numberFormat = {};\r\n    let targetLocale;\r\n    let format = null;\r\n    let from = locale;\r\n    let to = null;\r\n    const type = \'number format\';\r\n    for (let i = 0; i < locales.length; i++) {\r\n        targetLocale = to = locales[i];\r\n        if (false) {}\r\n        // for vue-devtools timeline event\r\n        if (false) {}\r\n        numberFormat =\r\n            numberFormats[targetLocale] || {};\r\n        format = numberFormat[key];\r\n        if (Object(shared_esm_bundler["l" /* isPlainObject */])(format))\r\n            break;\r\n        handleMissing(context, key, targetLocale, missingWarn, type);\r\n        from = to;\r\n    }\r\n    // checking format and target locale\r\n    if (!Object(shared_esm_bundler["l" /* isPlainObject */])(format) || !Object(shared_esm_bundler["n" /* isString */])(targetLocale)) {\r\n        return unresolving ? NOT_REOSLVED : key;\r\n    }\r\n    let id = `${targetLocale}__${key}`;\r\n    if (!Object(shared_esm_bundler["h" /* isEmptyObject */])(orverrides)) {\r\n        id = `${id}__${JSON.stringify(orverrides)}`;\r\n    }\r\n    let formatter = __numberFormatters.get(id);\r\n    if (!formatter) {\r\n        formatter = new Intl.NumberFormat(targetLocale, Object.assign({}, format, orverrides));\r\n        __numberFormatters.set(id, formatter);\r\n    }\r\n    return !part ? formatter.format(value) : formatter.formatToParts(value);\r\n}\r\n/** @internal */\r\nfunction parseNumberArgs(...args) {\r\n    const [arg1, arg2, arg3, arg4] = args;\r\n    let options = {};\r\n    let orverrides = {};\r\n    if (!Object(shared_esm_bundler["j" /* isNumber */])(arg1)) {\r\n        throw createCoreError(12 /* INVALID_ARGUMENT */);\r\n    }\r\n    const value = arg1;\r\n    if (Object(shared_esm_bundler["n" /* isString */])(arg2)) {\r\n        options.key = arg2;\r\n    }\r\n    else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg2)) {\r\n        options = arg2;\r\n    }\r\n    if (Object(shared_esm_bundler["n" /* isString */])(arg3)) {\r\n        options.locale = arg3;\r\n    }\r\n    else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg3)) {\r\n        orverrides = arg3;\r\n    }\r\n    if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg4)) {\r\n        orverrides = arg4;\r\n    }\r\n    return [options.key || \'\', value, options, orverrides];\r\n}\r\n/** @internal */\r\nfunction clearNumberFormat(ctx, locale, format) {\r\n    const context = ctx;\r\n    for (const key in format) {\r\n        const id = `${locale}__${key}`;\r\n        if (!context.__numberFormatters.has(id)) {\r\n            continue;\r\n        }\r\n        context.__numberFormatters.delete(id);\r\n    }\r\n}\n\nconst DevToolsLabels = {\r\n    ["vue-devtools-plugin-vue-i18n" /* PLUGIN */]: \'Vue I18n devtools\',\r\n    ["vue-i18n-resource-inspector" /* CUSTOM_INSPECTOR */]: \'I18n Resources\',\r\n    ["vue-i18n-compile-error" /* TIMELINE_COMPILE_ERROR */]: \'Vue I18n: Compile Errors\',\r\n    ["vue-i18n-missing" /* TIMELINE_MISSING */]: \'Vue I18n: Missing\',\r\n    ["vue-i18n-fallback" /* TIMELINE_FALLBACK */]: \'Vue I18n: Fallback\',\r\n    ["vue-i18n-performance" /* TIMELINE_PERFORMANCE */]: \'Vue I18n: Performance\'\r\n};\r\nconst DevToolsPlaceholders = {\r\n    ["vue-i18n-resource-inspector" /* CUSTOM_INSPECTOR */]: \'Search for scopes ...\'\r\n};\r\nconst DevToolsTimelineColors = {\r\n    ["vue-i18n-compile-error" /* TIMELINE_COMPILE_ERROR */]: 0xff0000,\r\n    ["vue-i18n-missing" /* TIMELINE_MISSING */]: 0xffcd19,\r\n    ["vue-i18n-fallback" /* TIMELINE_FALLBACK */]: 0xffcd19,\r\n    ["vue-i18n-performance" /* TIMELINE_PERFORMANCE */]: 0xffcd19\r\n};\r\nconst DevToolsTimelineLayerMaps = {\r\n    ["compile-error" /* COMPILE_ERROR */]: "vue-i18n-compile-error" /* TIMELINE_COMPILE_ERROR */,\r\n    ["missing" /* MISSING */]: "vue-i18n-missing" /* TIMELINE_MISSING */,\r\n    ["fallback" /* FALBACK */]: "vue-i18n-fallback" /* TIMELINE_FALLBACK */,\r\n    ["message-resolve" /* MESSAGE_RESOLVE */]: "vue-i18n-performance" /* TIMELINE_PERFORMANCE */,\r\n    ["message-compilation" /* MESSAGE_COMPILATION */]: "vue-i18n-performance" /* TIMELINE_PERFORMANCE */,\r\n    ["message-evaluation" /* MESSAGE_EVALUATION */]: "vue-i18n-performance" /* TIMELINE_PERFORMANCE */\r\n};\n\n/**\r\n * Event emitter, forked from the below:\r\n * - original repository url: https://github.com/developit/mitt\r\n * - code url: https://github.com/developit/mitt/blob/master/src/index.ts\r\n * - author: Jason Miller (https://github.com/developit)\r\n * - license: MIT\r\n */\r\n/**\r\n * Create a event emitter\r\n *\r\n * @returns An event emitter\r\n */\r\nfunction createEmitter() {\r\n    const events = new Map();\r\n    const emitter = {\r\n        events,\r\n        on(event, handler) {\r\n            const handlers = events.get(event);\r\n            const added = handlers && handlers.push(handler);\r\n            if (!added) {\r\n                events.set(event, [handler]);\r\n            }\r\n        },\r\n        off(event, handler) {\r\n            const handlers = events.get(event);\r\n            if (handlers) {\r\n                handlers.splice(handlers.indexOf(handler) >>> 0, 1);\r\n            }\r\n        },\r\n        emit(event, payload) {\r\n            (events.get(event) || [])\r\n                .slice()\r\n                .map(handler => handler(payload));\r\n            (events.get(\'*\') || [])\r\n                .slice()\r\n                .map(handler => handler(event, payload));\r\n        }\r\n    };\r\n    return emitter;\r\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm-bundler.js + 3 modules\nvar vue_runtime_esm_bundler = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/vue-i18n/dist/vue-i18n.esm-bundler.js\n/*!\n  * vue-i18n v9.0.0-beta.14\n  * (c) 2020 kazuya kawaguchi\n  * Released under the MIT License.\n  */\n\n\n\n\n\nlet devtools;\r\nfunction setDevtoolsHook(hook) {\r\n    devtools = hook;\r\n}\r\nfunction devtoolsRegisterI18n(i18n, version) {\r\n    if (!devtools) {\r\n        return;\r\n    }\r\n    devtools.emit("intlify:register" /* REGISTER */, i18n, version);\r\n}\r\nlet devtoolsApi;\r\nasync function enableDevTools(app, i18n) {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            Object(lib["setupDevtoolsPlugin"])({\r\n                id: "vue-devtools-plugin-vue-i18n" /* PLUGIN */,\r\n                label: DevToolsLabels["vue-devtools-plugin-vue-i18n" /* PLUGIN */],\r\n                app\r\n            }, api => {\r\n                devtoolsApi = api;\r\n                api.on.inspectComponent(payload => {\r\n                    const componentInstance = payload.componentInstance;\r\n                    if (componentInstance.vnode.el.__INTLIFY__ &&\r\n                        payload.instanceData) {\r\n                        inspectComposer(payload.instanceData, componentInstance.vnode.el.__INTLIFY__);\r\n                    }\r\n                });\r\n                api.addInspector({\r\n                    id: "vue-i18n-resource-inspector" /* CUSTOM_INSPECTOR */,\r\n                    label: DevToolsLabels["vue-i18n-resource-inspector" /* CUSTOM_INSPECTOR */],\r\n                    icon: \'language\',\r\n                    treeFilterPlaceholder: DevToolsPlaceholders["vue-i18n-resource-inspector" /* CUSTOM_INSPECTOR */]\r\n                });\r\n                api.on.getInspectorTree(payload => {\r\n                    if (payload.app === app &&\r\n                        payload.inspectorId === "vue-i18n-resource-inspector" /* CUSTOM_INSPECTOR */) {\r\n                        registerScope(payload, i18n);\r\n                    }\r\n                });\r\n                api.on.getInspectorState(payload => {\r\n                    if (payload.app === app &&\r\n                        payload.inspectorId === "vue-i18n-resource-inspector" /* CUSTOM_INSPECTOR */) {\r\n                        inspectScope(payload, i18n);\r\n                    }\r\n                });\r\n                api.addTimelineLayer({\r\n                    id: "vue-i18n-compile-error" /* TIMELINE_COMPILE_ERROR */,\r\n                    label: DevToolsLabels["vue-i18n-compile-error" /* TIMELINE_COMPILE_ERROR */],\r\n                    color: DevToolsTimelineColors["vue-i18n-compile-error" /* TIMELINE_COMPILE_ERROR */]\r\n                });\r\n                api.addTimelineLayer({\r\n                    id: "vue-i18n-performance" /* TIMELINE_PERFORMANCE */,\r\n                    label: DevToolsLabels["vue-i18n-performance" /* TIMELINE_PERFORMANCE */],\r\n                    color: DevToolsTimelineColors["vue-i18n-performance" /* TIMELINE_PERFORMANCE */]\r\n                });\r\n                api.addTimelineLayer({\r\n                    id: "vue-i18n-missing" /* TIMELINE_MISSING */,\r\n                    label: DevToolsLabels["vue-i18n-missing" /* TIMELINE_MISSING */],\r\n                    color: DevToolsTimelineColors["vue-i18n-missing" /* TIMELINE_MISSING */]\r\n                });\r\n                api.addTimelineLayer({\r\n                    id: "vue-i18n-fallback" /* TIMELINE_FALLBACK */,\r\n                    label: DevToolsLabels["vue-i18n-fallback" /* TIMELINE_FALLBACK */],\r\n                    color: DevToolsTimelineColors["vue-i18n-fallback" /* TIMELINE_FALLBACK */]\r\n                });\r\n                resolve(true);\r\n            });\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n            reject(false);\r\n        }\r\n    });\r\n}\r\nfunction inspectComposer(instanceData, composer) {\r\n    const type = \'vue-i18n: composer properties\';\r\n    instanceData.state.push({\r\n        type,\r\n        key: \'locale\',\r\n        editable: false,\r\n        value: composer.locale.value\r\n    });\r\n    instanceData.state.push({\r\n        type,\r\n        key: \'availableLocales\',\r\n        editable: false,\r\n        value: composer.availableLocales\r\n    });\r\n    instanceData.state.push({\r\n        type,\r\n        key: \'fallbackLocale\',\r\n        editable: false,\r\n        value: composer.fallbackLocale.value\r\n    });\r\n    instanceData.state.push({\r\n        type,\r\n        key: \'inheritLocale\',\r\n        editable: false,\r\n        value: composer.inheritLocale\r\n    });\r\n    instanceData.state.push({\r\n        type,\r\n        key: \'messages\',\r\n        editable: false,\r\n        value: composer.messages.value\r\n    });\r\n    instanceData.state.push({\r\n        type,\r\n        key: \'datetimeFormats\',\r\n        editable: false,\r\n        value: composer.datetimeFormats.value\r\n    });\r\n    instanceData.state.push({\r\n        type,\r\n        key: \'numberFormats\',\r\n        editable: false,\r\n        value: composer.numberFormats.value\r\n    });\r\n}\r\nfunction registerScope(payload, i18n) {\r\n    const children = [];\r\n    for (const [keyInstance, instance] of i18n.__instances) {\r\n        // prettier-ignore\r\n        const composer = i18n.mode === \'composition\'\r\n            ? instance\r\n            : instance.__composer;\r\n        const label = keyInstance.type.name ||\r\n            keyInstance.type.displayName ||\r\n            keyInstance.type.__file;\r\n        children.push({\r\n            id: composer.id.toString(),\r\n            label: `${label} Scope`\r\n        });\r\n    }\r\n    payload.rootNodes.push({\r\n        id: \'global\',\r\n        label: \'Global Scope\',\r\n        children\r\n    });\r\n}\r\nfunction inspectScope(payload, i18n) {\r\n    if (payload.nodeId === \'global\') {\r\n        payload.state = makeScopeInspectState(i18n.mode === \'composition\'\r\n            ? i18n.global\r\n            : i18n.global.__composer);\r\n    }\r\n    else {\r\n        const instance = Array.from(i18n.__instances.values()).find(item => item.id.toString() === payload.nodeId);\r\n        if (instance) {\r\n            const composer = i18n.mode === \'composition\'\r\n                ? instance\r\n                : instance.__composer;\r\n            payload.state = makeScopeInspectState(composer);\r\n        }\r\n    }\r\n}\r\nfunction makeScopeInspectState(composer) {\r\n    const state = {};\r\n    const localeType = \'Locale related info\';\r\n    const localeStates = [\r\n        {\r\n            type: localeType,\r\n            key: \'locale\',\r\n            editable: false,\r\n            value: composer.locale.value\r\n        },\r\n        {\r\n            type: localeType,\r\n            key: \'fallbackLocale\',\r\n            editable: false,\r\n            value: composer.fallbackLocale.value\r\n        },\r\n        {\r\n            type: localeType,\r\n            key: \'availableLocales\',\r\n            editable: false,\r\n            value: composer.availableLocales\r\n        },\r\n        {\r\n            type: localeType,\r\n            key: \'inheritLocale\',\r\n            editable: false,\r\n            value: composer.inheritLocale\r\n        }\r\n    ];\r\n    state[localeType] = localeStates;\r\n    const localeMessagesType = \'Locale messages info\';\r\n    const localeMessagesStates = [\r\n        {\r\n            type: localeMessagesType,\r\n            key: \'messages\',\r\n            editable: false,\r\n            value: composer.messages.value\r\n        }\r\n    ];\r\n    state[localeMessagesType] = localeMessagesStates;\r\n    const datetimeFormatsType = \'Datetime formats info\';\r\n    const datetimeFormatsStates = [\r\n        {\r\n            type: datetimeFormatsType,\r\n            key: \'datetimeFormats\',\r\n            editable: false,\r\n            value: composer.datetimeFormats.value\r\n        }\r\n    ];\r\n    state[datetimeFormatsType] = datetimeFormatsStates;\r\n    const numberFormatsType = \'Datetime formats info\';\r\n    const numberFormatsStates = [\r\n        {\r\n            type: numberFormatsType,\r\n            key: \'numberFormats\',\r\n            editable: false,\r\n            value: composer.numberFormats.value\r\n        }\r\n    ];\r\n    state[numberFormatsType] = numberFormatsStates;\r\n    return state;\r\n}\r\nfunction addTimelineEvent(event, payload) {\r\n    if (devtoolsApi) {\r\n        devtoolsApi.addTimelineEvent({\r\n            layerId: DevToolsTimelineLayerMaps[event],\r\n            event: {\r\n                time: Date.now(),\r\n                meta: {},\r\n                data: payload || {}\r\n            }\r\n        });\r\n    }\r\n}\n\n/**\r\n * Vue I18n Version\r\n *\r\n * @remarks\r\n * Semver format. Same format as the package.json `version` field.\r\n *\r\n * @VueI18nGeneral\r\n */\r\nconst VERSION = \'9.0.0-beta.14\';\r\n/**\r\n * This is only called in esm-bundler builds.\r\n * istanbul-ignore-next\r\n */\r\nfunction initFeatureFlags() {\r\n    let needWarn = false;\r\n    if (typeof __VUE_I18N_FULL_INSTALL__ !== \'boolean\') {\r\n        needWarn = true;\r\n        Object(shared_esm_bundler["d" /* getGlobalThis */])().__VUE_I18N_FULL_INSTALL__ = true;\r\n    }\r\n    if (typeof __VUE_I18N_LEGACY_API__ !== \'boolean\') {\r\n        needWarn = true;\r\n        Object(shared_esm_bundler["d" /* getGlobalThis */])().__VUE_I18N_LEGACY_API__ = true;\r\n    }\r\n    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== \'boolean\') {\r\n        needWarn = true;\r\n        Object(shared_esm_bundler["d" /* getGlobalThis */])().__INTLIFY_PROD_DEVTOOLS__ = false;\r\n    }\r\n    if (false) {}\r\n}\r\n/**\r\n * This is only called development env\r\n * istanbul-ignore-next\r\n */\r\nfunction initDev() {\r\n    const target = Object(shared_esm_bundler["d" /* getGlobalThis */])();\r\n    target.__INTLIFY__ = true;\r\n    setDevtoolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);\r\n    {\r\n        console.info(`You are running a development build of vue-i18n.\\n` +\r\n            `Make sure to use the production build (*.prod.js) when deploying for production.`);\r\n    }\r\n}\n\nconst vue_i18n_esm_bundler_warnMessages = {\r\n    [6 /* FALLBACK_TO_ROOT */]: `Fall back to {type} \'{key}\' with root locale.`,\r\n    [7 /* NOT_SUPPORTED_PRESERVE */]: `Not supportted \'preserve\'.`,\r\n    [8 /* NOT_SUPPORTED_FORMATTER */]: `Not supportted \'formatter\'.`,\r\n    [9 /* NOT_SUPPORTED_PRESERVE_DIRECTIVE */]: `Not supportted \'preserveDirectiveContent\'.`,\r\n    [10 /* NOT_SUPPORTED_GET_CHOICE_INDEX */]: `Not supportted \'getChoiceIndex\'.`,\r\n    [11 /* COMPONENT_NAME_LEGACY_COMPATIBLE */]: `Component name legacy compatible: \'{name}\' -> \'i18n\'`,\r\n    [12 /* NOT_FOUND_PARENT_SCOPE */]: `Not found parent scope. use the global scope.`\r\n};\r\nfunction vue_i18n_esm_bundler_getWarnMessage(code, ...args) {\r\n    return Object(shared_esm_bundler["b" /* format */])(vue_i18n_esm_bundler_warnMessages[code], ...args);\r\n}\n\nfunction createI18nError(code, ...args) {\r\n    return createCompileError(code, null, ( false) ? undefined : undefined);\r\n}\r\nconst vue_i18n_esm_bundler_errorMessages = {\r\n    [12 /* UNEXPECTED_RETURN_TYPE */]: \'Unexpected return type in composer\',\r\n    [13 /* INVALID_ARGUMENT */]: \'Invalid argument\',\r\n    [14 /* MUST_BE_CALL_SETUP_TOP */]: \'Must be called at the top of a `setup` function\',\r\n    [15 /* NOT_INSLALLED */]: \'Need to install with `app.use` function\',\r\n    [20 /* UNEXPECTED_ERROR */]: \'Unexpected error\',\r\n    [16 /* NOT_AVAILABLE_IN_LEGACY_MODE */]: \'Not available in legacy mode\',\r\n    [17 /* REQUIRED_VALUE */]: `Required in value: {0}`,\r\n    [18 /* INVALID_VALUE */]: `Invalid value`,\r\n    [19 /* CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN */]: `Cannot setup vue-devtools plugin`\r\n};\n\n/**\r\n *  Composer\r\n *\r\n *  Composer is offered composable API for Vue 3\r\n *  This module is offered new style vue-i18n API\r\n */\r\nconst TransrateVNodeSymbol = Object(shared_esm_bundler["o" /* makeSymbol */])(\'__transrateVNode\');\r\nconst DatetimePartsSymbol = Object(shared_esm_bundler["o" /* makeSymbol */])(\'__datetimeParts\');\r\nconst NumberPartsSymbol = Object(shared_esm_bundler["o" /* makeSymbol */])(\'__numberParts\');\r\nconst EnableEmitter = Object(shared_esm_bundler["o" /* makeSymbol */])(\'__enableEmitter\');\r\nconst DisableEmitter = Object(shared_esm_bundler["o" /* makeSymbol */])(\'__disableEmitter\');\r\nlet composerID = 0;\r\nfunction defineCoreMissingHandler(missing) {\r\n    return ((ctx, locale, key, type) => {\r\n        return missing(locale, key, Object(vue_runtime_esm_bundler["getCurrentInstance"])() || undefined, type);\r\n    });\r\n}\r\nfunction getLocaleMessages(locale, options) {\r\n    const { messages, __i18n } = options;\r\n    // prettier-ignore\r\n    const ret = Object(shared_esm_bundler["l" /* isPlainObject */])(messages)\r\n        ? messages\r\n        : Object(shared_esm_bundler["e" /* isArray */])(__i18n)\r\n            ? {}\r\n            : { [locale]: {} };\r\n    // merge locale messages of i18n custom block\r\n    if (Object(shared_esm_bundler["e" /* isArray */])(__i18n)) {\r\n        __i18n.forEach(raw => {\r\n            deepCopy(Object(shared_esm_bundler["n" /* isString */])(raw) ? JSON.parse(raw) : raw, ret);\r\n        });\r\n        return ret;\r\n    }\r\n    if (Object(shared_esm_bundler["i" /* isFunction */])(__i18n)) {\r\n        const { functions } = __i18n();\r\n        addPreCompileMessages(ret, functions);\r\n    }\r\n    return ret;\r\n}\r\nconst vue_i18n_esm_bundler_hasOwnProperty = Object.prototype.hasOwnProperty;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction hasOwn(obj, key) {\r\n    return vue_i18n_esm_bundler_hasOwnProperty.call(obj, key);\r\n}\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction deepCopy(source, destination) {\r\n    for (const key in source) {\r\n        if (hasOwn(source, key)) {\r\n            if (!Object(shared_esm_bundler["k" /* isObject */])(source[key])) {\r\n                destination[key] = destination[key] != null ? destination[key] : {};\r\n                destination[key] = source[key];\r\n            }\r\n            else {\r\n                destination[key] = destination[key] != null ? destination[key] : {};\r\n                deepCopy(source[key], destination[key]);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction addPreCompileMessages(messages, functions) {\r\n    const keys = Object.keys(functions);\r\n    keys.forEach(key => {\r\n        const compiled = functions[key];\r\n        const { l, k } = JSON.parse(key);\r\n        if (!messages[l]) {\r\n            messages[l] = {};\r\n        }\r\n        const targetLocaleMessage = messages[l];\r\n        const paths = parse(k);\r\n        if (paths != null) {\r\n            const len = paths.length;\r\n            let last = targetLocaleMessage; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n            let i = 0;\r\n            while (i < len) {\r\n                const path = paths[i];\r\n                if (i === len - 1) {\r\n                    last[path] = compiled;\r\n                    break;\r\n                }\r\n                else {\r\n                    let val = last[path];\r\n                    if (!val) {\r\n                        last[path] = val = {};\r\n                    }\r\n                    last = val;\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n/**\r\n * Create composer interface factory\r\n *\r\n * @internal\r\n */\r\nfunction createComposer(options = {}) {\r\n    const { __root } = options;\r\n    const _isGlobal = __root === undefined;\r\n    let _inheritLocale = Object(shared_esm_bundler["f" /* isBoolean */])(options.inheritLocale)\r\n        ? options.inheritLocale\r\n        : true;\r\n    const _locale = Object(vue_runtime_esm_bundler["ref"])(\r\n    // prettier-ignore\r\n    __root && _inheritLocale\r\n        ? __root.locale.value\r\n        : Object(shared_esm_bundler["n" /* isString */])(options.locale)\r\n            ? options.locale\r\n            : \'en-US\');\r\n    const _fallbackLocale = Object(vue_runtime_esm_bundler["ref"])(\r\n    // prettier-ignore\r\n    __root && _inheritLocale\r\n        ? __root.fallbackLocale.value\r\n        : Object(shared_esm_bundler["n" /* isString */])(options.fallbackLocale) ||\r\n            Object(shared_esm_bundler["e" /* isArray */])(options.fallbackLocale) ||\r\n            Object(shared_esm_bundler["l" /* isPlainObject */])(options.fallbackLocale) ||\r\n            options.fallbackLocale === false\r\n            ? options.fallbackLocale\r\n            : _locale.value);\r\n    const _messages = Object(vue_runtime_esm_bundler["ref"])(getLocaleMessages(_locale.value, options));\r\n    const _datetimeFormats = Object(vue_runtime_esm_bundler["ref"])(Object(shared_esm_bundler["l" /* isPlainObject */])(options.datetimeFormats)\r\n        ? options.datetimeFormats\r\n        : { [_locale.value]: {} });\r\n    const _numberFormats = Object(vue_runtime_esm_bundler["ref"])(Object(shared_esm_bundler["l" /* isPlainObject */])(options.numberFormats)\r\n        ? options.numberFormats\r\n        : { [_locale.value]: {} });\r\n    // warning suppress options\r\n    // prettier-ignore\r\n    let _missingWarn = __root\r\n        ? __root.missingWarn\r\n        : Object(shared_esm_bundler["f" /* isBoolean */])(options.missingWarn) || Object(shared_esm_bundler["m" /* isRegExp */])(options.missingWarn)\r\n            ? options.missingWarn\r\n            : true;\r\n    // prettier-ignore\r\n    let _fallbackWarn = __root\r\n        ? __root.fallbackWarn\r\n        : Object(shared_esm_bundler["f" /* isBoolean */])(options.fallbackWarn) || Object(shared_esm_bundler["m" /* isRegExp */])(options.fallbackWarn)\r\n            ? options.fallbackWarn\r\n            : true;\r\n    let _fallbackRoot = Object(shared_esm_bundler["f" /* isBoolean */])(options.fallbackRoot)\r\n        ? options.fallbackRoot\r\n        : true;\r\n    // configure fall bakck to root\r\n    let _fallbackFormat = !!options.fallbackFormat;\r\n    // runtime missing\r\n    let _missing = Object(shared_esm_bundler["i" /* isFunction */])(options.missing) ? options.missing : null;\r\n    let _runtimeMissing = Object(shared_esm_bundler["i" /* isFunction */])(options.missing)\r\n        ? defineCoreMissingHandler(options.missing)\r\n        : null;\r\n    // postTranslation handler\r\n    let _postTranslation = Object(shared_esm_bundler["i" /* isFunction */])(options.postTranslation)\r\n        ? options.postTranslation\r\n        : null;\r\n    let _warnHtmlMessage = Object(shared_esm_bundler["f" /* isBoolean */])(options.warnHtmlMessage)\r\n        ? options.warnHtmlMessage\r\n        : true;\r\n    let _escapeParameter = !!options.escapeParameter;\r\n    // custom linked modifiers\r\n    // prettier-ignore\r\n    const _modifiers = __root\r\n        ? __root.modifiers\r\n        : Object(shared_esm_bundler["l" /* isPlainObject */])(options.modifiers)\r\n            ? options.modifiers\r\n            : {};\r\n    // pluralRules\r\n    const _pluralRules = options.pluralRules;\r\n    // runtime context\r\n    // eslint-disable-next-line prefer-const\r\n    let _context;\r\n    function getCoreContext() {\r\n        return createCoreContext({\r\n            locale: _locale.value,\r\n            fallbackLocale: _fallbackLocale.value,\r\n            messages: _messages.value,\r\n            datetimeFormats: _datetimeFormats.value,\r\n            numberFormats: _numberFormats.value,\r\n            modifiers: _modifiers,\r\n            pluralRules: _pluralRules,\r\n            missing: _runtimeMissing === null ? undefined : _runtimeMissing,\r\n            missingWarn: _missingWarn,\r\n            fallbackWarn: _fallbackWarn,\r\n            fallbackFormat: _fallbackFormat,\r\n            unresolving: true,\r\n            postTranslation: _postTranslation === null ? undefined : _postTranslation,\r\n            warnHtmlMessage: _warnHtmlMessage,\r\n            escapeParameter: _escapeParameter,\r\n            __datetimeFormatters: Object(shared_esm_bundler["l" /* isPlainObject */])(_context)\r\n                ? _context.__datetimeFormatters\r\n                : undefined,\r\n            __numberFormatters: Object(shared_esm_bundler["l" /* isPlainObject */])(_context)\r\n                ? _context.__numberFormatters\r\n                : undefined,\r\n            __emitter: Object(shared_esm_bundler["l" /* isPlainObject */])(_context)\r\n                ? _context.__emitter\r\n                : undefined\r\n        });\r\n    }\r\n    _context = getCoreContext();\r\n    updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\r\n    /*!\r\n     * define properties\r\n     */\r\n    // locale\r\n    const locale = Object(vue_runtime_esm_bundler["computed"])({\r\n        get: () => _locale.value,\r\n        set: val => {\r\n            _locale.value = val;\r\n            _context.locale = _locale.value;\r\n        }\r\n    });\r\n    // fallbackLocale\r\n    const fallbackLocale = Object(vue_runtime_esm_bundler["computed"])({\r\n        get: () => _fallbackLocale.value,\r\n        set: val => {\r\n            _fallbackLocale.value = val;\r\n            _context.fallbackLocale = _fallbackLocale.value;\r\n            updateFallbackLocale(_context, _locale.value, val);\r\n        }\r\n    });\r\n    // messages\r\n    const messages = Object(vue_runtime_esm_bundler["computed"])(() => _messages.value);\r\n    // datetimeFormats\r\n    const datetimeFormats = Object(vue_runtime_esm_bundler["computed"])(() => _datetimeFormats.value);\r\n    // numberFormats\r\n    const numberFormats = Object(vue_runtime_esm_bundler["computed"])(() => _numberFormats.value);\r\n    /**\r\n     * define methods\r\n     */\r\n    // getPostTranslationHandler\r\n    function getPostTranslationHandler() {\r\n        return Object(shared_esm_bundler["i" /* isFunction */])(_postTranslation) ? _postTranslation : null;\r\n    }\r\n    // setPostTranslationHandler\r\n    function setPostTranslationHandler(handler) {\r\n        _postTranslation = handler;\r\n        _context.postTranslation = handler;\r\n    }\r\n    // getMissingHandler\r\n    function getMissingHandler() {\r\n        return _missing;\r\n    }\r\n    // setMissingHandler\r\n    function setMissingHandler(handler) {\r\n        if (handler !== null) {\r\n            _runtimeMissing = defineCoreMissingHandler(handler);\r\n        }\r\n        _missing = handler;\r\n        _context.missing = _runtimeMissing;\r\n    }\r\n    function wrapWithDeps(fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) {\r\n        const context = getCoreContext();\r\n        const ret = fn(context); // track reactive dependency, see the getRuntimeContext\r\n        if (Object(shared_esm_bundler["j" /* isNumber */])(ret) && ret === NOT_REOSLVED) {\r\n            const key = argumentParser();\r\n            if (false) {}\r\n            return _fallbackRoot && __root\r\n                ? fallbackSuccess(__root)\r\n                : fallbackFail(key);\r\n        }\r\n        else if (successCondition(ret)) {\r\n            return ret;\r\n        }\r\n        else {\r\n            /* istanbul ignore next */\r\n            throw createI18nError(12 /* UNEXPECTED_RETURN_TYPE */);\r\n        }\r\n    }\r\n    // t\r\n    function t(...args) {\r\n        return wrapWithDeps(context => translate(context, ...args), () => parseTranslateArgs(...args)[0], \'translate\', root => root.t(...args), key => key, val => Object(shared_esm_bundler["n" /* isString */])(val));\r\n    }\r\n    // d\r\n    function d(...args) {\r\n        return wrapWithDeps(context => datetime(context, ...args), () => parseDateTimeArgs(...args)[0], \'datetime format\', root => root.d(...args), () => MISSING_RESOLVE_VALUE, val => Object(shared_esm_bundler["n" /* isString */])(val));\r\n    }\r\n    // n\r\n    function n(...args) {\r\n        return wrapWithDeps(context => number(context, ...args), () => parseNumberArgs(...args)[0], \'number format\', root => root.n(...args), () => MISSING_RESOLVE_VALUE, val => Object(shared_esm_bundler["n" /* isString */])(val));\r\n    }\r\n    // for custom processor\r\n    function normalize(values) {\r\n        return values.map(val => Object(shared_esm_bundler["n" /* isString */])(val) ? Object(vue_runtime_esm_bundler["createVNode"])(vue_runtime_esm_bundler["Text"], null, val, 0) : val);\r\n    }\r\n    const interpolate = (val) => val;\r\n    const processor = {\r\n        normalize,\r\n        interpolate,\r\n        type: \'vnode\'\r\n    };\r\n    // __transrateVNode, using for `i18n-t` component\r\n    function __transrateVNode(...args) {\r\n        return wrapWithDeps(context => {\r\n            let ret;\r\n            const _context = context;\r\n            try {\r\n                _context.processor = processor;\r\n                ret = translate(_context, ...args);\r\n            }\r\n            finally {\r\n                _context.processor = null;\r\n            }\r\n            return ret;\r\n        }, () => parseTranslateArgs(...args)[0], \'translate\', \r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        root => root[TransrateVNodeSymbol](...args), key => [Object(vue_runtime_esm_bundler["createVNode"])(vue_runtime_esm_bundler["Text"], null, key, 0)], val => Object(shared_esm_bundler["e" /* isArray */])(val));\r\n    }\r\n    // __numberParts, using for `i18n-n` component\r\n    function __numberParts(...args) {\r\n        return wrapWithDeps(context => number(context, ...args), () => parseNumberArgs(...args)[0], \'number format\', \r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        root => root[NumberPartsSymbol](...args), () => [], val => Object(shared_esm_bundler["n" /* isString */])(val) || Object(shared_esm_bundler["e" /* isArray */])(val));\r\n    }\r\n    // __datetimeParts, using for `i18n-d` component\r\n    function __datetimeParts(...args) {\r\n        return wrapWithDeps(context => datetime(context, ...args), () => parseDateTimeArgs(...args)[0], \'datetime format\', \r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        root => root[DatetimePartsSymbol](...args), () => [], val => Object(shared_esm_bundler["n" /* isString */])(val) || Object(shared_esm_bundler["e" /* isArray */])(val));\r\n    }\r\n    // te\r\n    function te(key, locale) {\r\n        const targetLocale = Object(shared_esm_bundler["n" /* isString */])(locale) ? locale : _locale.value;\r\n        const message = getLocaleMessage(targetLocale);\r\n        return resolveValue(message, key) !== null;\r\n    }\r\n    // tm\r\n    function tm(key) {\r\n        const messages = _messages.value[_locale.value] || {};\r\n        const target = resolveValue(messages, key);\r\n        // prettier-ignore\r\n        return target != null\r\n            ? target\r\n            : __root\r\n                ? __root.tm(key) || {}\r\n                : {};\r\n    }\r\n    // getLocaleMessage\r\n    function getLocaleMessage(locale) {\r\n        return (_messages.value[locale] || {});\r\n    }\r\n    // setLocaleMessage\r\n    function setLocaleMessage(locale, message) {\r\n        _messages.value[locale] = message;\r\n        _context.messages = _messages.value;\r\n    }\r\n    // mergeLocaleMessage\r\n    function mergeLocaleMessage(locale, message) {\r\n        _messages.value[locale] = Object.assign(_messages.value[locale] || {}, message);\r\n        _context.messages = _messages.value;\r\n    }\r\n    // getDateTimeFormat\r\n    function getDateTimeFormat(locale) {\r\n        return _datetimeFormats.value[locale] || {};\r\n    }\r\n    // setDateTimeFormat\r\n    function setDateTimeFormat(locale, format) {\r\n        _datetimeFormats.value[locale] = format;\r\n        _context.datetimeFormats = _datetimeFormats.value;\r\n        clearDateTimeFormat(_context, locale, format);\r\n    }\r\n    // mergeDateTimeFormat\r\n    function mergeDateTimeFormat(locale, format) {\r\n        _datetimeFormats.value[locale] = Object.assign(_datetimeFormats.value[locale] || {}, format);\r\n        _context.datetimeFormats = _datetimeFormats.value;\r\n        clearDateTimeFormat(_context, locale, format);\r\n    }\r\n    // getNumberFormat\r\n    function getNumberFormat(locale) {\r\n        return _numberFormats.value[locale] || {};\r\n    }\r\n    // setNumberFormat\r\n    function setNumberFormat(locale, format) {\r\n        _numberFormats.value[locale] = format;\r\n        _context.numberFormats = _numberFormats.value;\r\n        clearNumberFormat(_context, locale, format);\r\n    }\r\n    // mergeNumberFormat\r\n    function mergeNumberFormat(locale, format) {\r\n        _numberFormats.value[locale] = Object.assign(_numberFormats.value[locale] || {}, format);\r\n        _context.numberFormats = _numberFormats.value;\r\n        clearNumberFormat(_context, locale, format);\r\n    }\r\n    // for debug\r\n    composerID++;\r\n    // watch root locale & fallbackLocale\r\n    if (__root) {\r\n        Object(vue_runtime_esm_bundler["watch"])(__root.locale, (val) => {\r\n            if (_inheritLocale) {\r\n                _locale.value = val;\r\n                _context.locale = val;\r\n                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\r\n            }\r\n        });\r\n        Object(vue_runtime_esm_bundler["watch"])(__root.fallbackLocale, (val) => {\r\n            if (_inheritLocale) {\r\n                _fallbackLocale.value = val;\r\n                _context.fallbackLocale = val;\r\n                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\r\n            }\r\n        });\r\n    }\r\n    // export composition API!\r\n    const composer = {\r\n        // properties\r\n        id: composerID,\r\n        locale,\r\n        fallbackLocale,\r\n        get inheritLocale() {\r\n            return _inheritLocale;\r\n        },\r\n        set inheritLocale(val) {\r\n            _inheritLocale = val;\r\n            if (val && __root) {\r\n                _locale.value = __root.locale.value;\r\n                _fallbackLocale.value = __root.fallbackLocale.value;\r\n                updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);\r\n            }\r\n        },\r\n        get availableLocales() {\r\n            return Object.keys(_messages.value).sort();\r\n        },\r\n        messages,\r\n        datetimeFormats,\r\n        numberFormats,\r\n        get modifiers() {\r\n            return _modifiers;\r\n        },\r\n        get pluralRules() {\r\n            return _pluralRules || {};\r\n        },\r\n        get isGlobal() {\r\n            return _isGlobal;\r\n        },\r\n        get missingWarn() {\r\n            return _missingWarn;\r\n        },\r\n        set missingWarn(val) {\r\n            _missingWarn = val;\r\n            _context.missingWarn = _missingWarn;\r\n        },\r\n        get fallbackWarn() {\r\n            return _fallbackWarn;\r\n        },\r\n        set fallbackWarn(val) {\r\n            _fallbackWarn = val;\r\n            _context.fallbackWarn = _fallbackWarn;\r\n        },\r\n        get fallbackRoot() {\r\n            return _fallbackRoot;\r\n        },\r\n        set fallbackRoot(val) {\r\n            _fallbackRoot = val;\r\n        },\r\n        get fallbackFormat() {\r\n            return _fallbackFormat;\r\n        },\r\n        set fallbackFormat(val) {\r\n            _fallbackFormat = val;\r\n            _context.fallbackFormat = _fallbackFormat;\r\n        },\r\n        get warnHtmlMessage() {\r\n            return _warnHtmlMessage;\r\n        },\r\n        set warnHtmlMessage(val) {\r\n            _warnHtmlMessage = val;\r\n            _context.warnHtmlMessage = val;\r\n        },\r\n        get escapeParameter() {\r\n            return _escapeParameter;\r\n        },\r\n        set escapeParameter(val) {\r\n            _escapeParameter = val;\r\n            _context.escapeParameter = val;\r\n        },\r\n        // methods\r\n        t,\r\n        d,\r\n        n,\r\n        te,\r\n        tm,\r\n        getLocaleMessage,\r\n        setLocaleMessage,\r\n        mergeLocaleMessage,\r\n        getDateTimeFormat,\r\n        setDateTimeFormat,\r\n        mergeDateTimeFormat,\r\n        getNumberFormat,\r\n        setNumberFormat,\r\n        mergeNumberFormat,\r\n        getPostTranslationHandler,\r\n        setPostTranslationHandler,\r\n        getMissingHandler,\r\n        setMissingHandler,\r\n        [TransrateVNodeSymbol]: __transrateVNode,\r\n        [NumberPartsSymbol]: __numberParts,\r\n        [DatetimePartsSymbol]: __datetimeParts\r\n    };\r\n    // for vue-devtools timeline event\r\n    if ((false)) {}\r\n    return composer;\r\n}\n\n/**\r\n *  Legacy\r\n *\r\n *  This module is offered legacy vue-i18n API compatibility\r\n */\r\n/**\r\n * Convert to I18n Composer Options from VueI18n Options\r\n *\r\n * @internal\r\n */\r\nfunction convertComposerOptions(options) {\r\n    const locale = Object(shared_esm_bundler["n" /* isString */])(options.locale) ? options.locale : \'en-US\';\r\n    const fallbackLocale = Object(shared_esm_bundler["n" /* isString */])(options.fallbackLocale) ||\r\n        Object(shared_esm_bundler["e" /* isArray */])(options.fallbackLocale) ||\r\n        Object(shared_esm_bundler["l" /* isPlainObject */])(options.fallbackLocale) ||\r\n        options.fallbackLocale === false\r\n        ? options.fallbackLocale\r\n        : locale;\r\n    const missing = Object(shared_esm_bundler["i" /* isFunction */])(options.missing) ? options.missing : undefined;\r\n    const missingWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.silentTranslationWarn) ||\r\n        Object(shared_esm_bundler["m" /* isRegExp */])(options.silentTranslationWarn)\r\n        ? !options.silentTranslationWarn\r\n        : true;\r\n    const fallbackWarn = Object(shared_esm_bundler["f" /* isBoolean */])(options.silentFallbackWarn) ||\r\n        Object(shared_esm_bundler["m" /* isRegExp */])(options.silentFallbackWarn)\r\n        ? !options.silentFallbackWarn\r\n        : true;\r\n    const fallbackRoot = Object(shared_esm_bundler["f" /* isBoolean */])(options.fallbackRoot)\r\n        ? options.fallbackRoot\r\n        : true;\r\n    const fallbackFormat = !!options.formatFallbackMessages;\r\n    const modifiers = Object(shared_esm_bundler["l" /* isPlainObject */])(options.modifiers) ? options.modifiers : {};\r\n    const pluralizationRules = options.pluralizationRules;\r\n    const postTranslation = Object(shared_esm_bundler["i" /* isFunction */])(options.postTranslation)\r\n        ? options.postTranslation\r\n        : undefined;\r\n    const warnHtmlMessage = Object(shared_esm_bundler["n" /* isString */])(options.warnHtmlInMessage)\r\n        ? options.warnHtmlInMessage !== \'off\'\r\n        : true;\r\n    const escapeParameter = !!options.escapeParameterHtml;\r\n    const inheritLocale = Object(shared_esm_bundler["f" /* isBoolean */])(options.sync) ? options.sync : true;\r\n    if (false) {}\r\n    if (false) {}\r\n    let messages = options.messages;\r\n    if (Object(shared_esm_bundler["l" /* isPlainObject */])(options.sharedMessages)) {\r\n        const sharedMessages = options.sharedMessages;\r\n        const locales = Object.keys(sharedMessages);\r\n        messages = locales.reduce((messages, locale) => {\r\n            const message = messages[locale] || (messages[locale] = {});\r\n            Object.assign(message, sharedMessages[locale]);\r\n            return messages;\r\n        }, (messages || {}));\r\n    }\r\n    const { __i18n, __root } = options;\r\n    const datetimeFormats = options.datetimeFormats;\r\n    const numberFormats = options.numberFormats;\r\n    return {\r\n        locale,\r\n        fallbackLocale,\r\n        messages,\r\n        datetimeFormats,\r\n        numberFormats,\r\n        missing,\r\n        missingWarn,\r\n        fallbackWarn,\r\n        fallbackRoot,\r\n        fallbackFormat,\r\n        modifiers,\r\n        pluralRules: pluralizationRules,\r\n        postTranslation,\r\n        warnHtmlMessage,\r\n        escapeParameter,\r\n        inheritLocale,\r\n        __i18n,\r\n        __root\r\n    };\r\n}\r\n/**\r\n * create VueI18n interface factory\r\n *\r\n * @internal\r\n */\r\nfunction createVueI18n(options = {}) {\r\n    const composer = createComposer(convertComposerOptions(options));\r\n    // defines VueI18n\r\n    const vueI18n = {\r\n        /**\r\n         * properties\r\n         */\r\n        // id\r\n        id: composer.id,\r\n        // locale\r\n        get locale() {\r\n            return composer.locale.value;\r\n        },\r\n        set locale(val) {\r\n            composer.locale.value = val;\r\n        },\r\n        // fallbackLocale\r\n        get fallbackLocale() {\r\n            return composer.fallbackLocale.value;\r\n        },\r\n        set fallbackLocale(val) {\r\n            composer.fallbackLocale.value = val;\r\n        },\r\n        // messages\r\n        get messages() {\r\n            return composer.messages.value;\r\n        },\r\n        // datetimeFormats\r\n        get datetimeFormats() {\r\n            return composer.datetimeFormats.value;\r\n        },\r\n        // numberFormats\r\n        get numberFormats() {\r\n            return composer.numberFormats.value;\r\n        },\r\n        // availableLocales\r\n        get availableLocales() {\r\n            return composer.availableLocales;\r\n        },\r\n        // formatter\r\n        get formatter() {\r\n            ( false) && false;\r\n            // dummy\r\n            return {\r\n                interpolate() {\r\n                    return [];\r\n                }\r\n            };\r\n        },\r\n        set formatter(val) {\r\n            ( false) && false;\r\n        },\r\n        // missing\r\n        get missing() {\r\n            return composer.getMissingHandler();\r\n        },\r\n        set missing(handler) {\r\n            composer.setMissingHandler(handler);\r\n        },\r\n        // silentTranslationWarn\r\n        get silentTranslationWarn() {\r\n            return Object(shared_esm_bundler["f" /* isBoolean */])(composer.missingWarn)\r\n                ? !composer.missingWarn\r\n                : composer.missingWarn;\r\n        },\r\n        set silentTranslationWarn(val) {\r\n            composer.missingWarn = Object(shared_esm_bundler["f" /* isBoolean */])(val) ? !val : val;\r\n        },\r\n        // silentFallbackWarn\r\n        get silentFallbackWarn() {\r\n            return Object(shared_esm_bundler["f" /* isBoolean */])(composer.fallbackWarn)\r\n                ? !composer.fallbackWarn\r\n                : composer.fallbackWarn;\r\n        },\r\n        set silentFallbackWarn(val) {\r\n            composer.fallbackWarn = Object(shared_esm_bundler["f" /* isBoolean */])(val) ? !val : val;\r\n        },\r\n        // modifiers\r\n        get modifiers() {\r\n            return composer.modifiers;\r\n        },\r\n        // formatFallbackMessages\r\n        get formatFallbackMessages() {\r\n            return composer.fallbackFormat;\r\n        },\r\n        set formatFallbackMessages(val) {\r\n            composer.fallbackFormat = val;\r\n        },\r\n        // postTranslation\r\n        get postTranslation() {\r\n            return composer.getPostTranslationHandler();\r\n        },\r\n        set postTranslation(handler) {\r\n            composer.setPostTranslationHandler(handler);\r\n        },\r\n        // sync\r\n        get sync() {\r\n            return composer.inheritLocale;\r\n        },\r\n        set sync(val) {\r\n            composer.inheritLocale = val;\r\n        },\r\n        // warnInHtmlMessage\r\n        get warnHtmlInMessage() {\r\n            return composer.warnHtmlMessage ? \'warn\' : \'off\';\r\n        },\r\n        set warnHtmlInMessage(val) {\r\n            composer.warnHtmlMessage = val !== \'off\';\r\n        },\r\n        // escapeParameterHtml\r\n        get escapeParameterHtml() {\r\n            return composer.escapeParameter;\r\n        },\r\n        set escapeParameterHtml(val) {\r\n            composer.escapeParameter = val;\r\n        },\r\n        // preserveDirectiveContent\r\n        get preserveDirectiveContent() {\r\n            ( false) &&\r\n                false;\r\n            return true;\r\n        },\r\n        set preserveDirectiveContent(val) {\r\n            ( false) &&\r\n                false;\r\n        },\r\n        // pluralizationRules\r\n        get pluralizationRules() {\r\n            return composer.pluralRules || {};\r\n        },\r\n        // for internal\r\n        __composer: composer,\r\n        /**\r\n         * methods\r\n         */\r\n        // t\r\n        t(...args) {\r\n            const [arg1, arg2, arg3] = args;\r\n            const options = {};\r\n            let list = null;\r\n            let named = null;\r\n            if (!Object(shared_esm_bundler["n" /* isString */])(arg1)) {\r\n                throw createI18nError(13 /* INVALID_ARGUMENT */);\r\n            }\r\n            const key = arg1;\r\n            if (Object(shared_esm_bundler["n" /* isString */])(arg2)) {\r\n                options.locale = arg2;\r\n            }\r\n            else if (Object(shared_esm_bundler["e" /* isArray */])(arg2)) {\r\n                list = arg2;\r\n            }\r\n            else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg2)) {\r\n                named = arg2;\r\n            }\r\n            if (Object(shared_esm_bundler["e" /* isArray */])(arg3)) {\r\n                list = arg3;\r\n            }\r\n            else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg3)) {\r\n                named = arg3;\r\n            }\r\n            return composer.t(key, list || named || {}, options);\r\n        },\r\n        // tc\r\n        tc(...args) {\r\n            const [arg1, arg2, arg3] = args;\r\n            const options = { plural: 1 };\r\n            let list = null;\r\n            let named = null;\r\n            if (!Object(shared_esm_bundler["n" /* isString */])(arg1)) {\r\n                throw createI18nError(13 /* INVALID_ARGUMENT */);\r\n            }\r\n            const key = arg1;\r\n            if (Object(shared_esm_bundler["n" /* isString */])(arg2)) {\r\n                options.locale = arg2;\r\n            }\r\n            else if (Object(shared_esm_bundler["j" /* isNumber */])(arg2)) {\r\n                options.plural = arg2;\r\n            }\r\n            else if (Object(shared_esm_bundler["e" /* isArray */])(arg2)) {\r\n                list = arg2;\r\n            }\r\n            else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg2)) {\r\n                named = arg2;\r\n            }\r\n            if (Object(shared_esm_bundler["n" /* isString */])(arg3)) {\r\n                options.locale = arg3;\r\n            }\r\n            else if (Object(shared_esm_bundler["e" /* isArray */])(arg3)) {\r\n                list = arg3;\r\n            }\r\n            else if (Object(shared_esm_bundler["l" /* isPlainObject */])(arg3)) {\r\n                named = arg3;\r\n            }\r\n            return composer.t(key, list || named || {}, options);\r\n        },\r\n        // te\r\n        te(key, locale) {\r\n            return composer.te(key, locale);\r\n        },\r\n        // tm\r\n        tm(key) {\r\n            return composer.tm(key);\r\n        },\r\n        // getLocaleMessage\r\n        getLocaleMessage(locale) {\r\n            return composer.getLocaleMessage(locale);\r\n        },\r\n        // setLocaleMessage\r\n        setLocaleMessage(locale, message) {\r\n            composer.setLocaleMessage(locale, message);\r\n        },\r\n        // mergeLocaleMessasge\r\n        mergeLocaleMessage(locale, message) {\r\n            composer.mergeLocaleMessage(locale, message);\r\n        },\r\n        // d\r\n        d(...args) {\r\n            return composer.d(...args);\r\n        },\r\n        // getDateTimeFormat\r\n        getDateTimeFormat(locale) {\r\n            return composer.getDateTimeFormat(locale);\r\n        },\r\n        // setDateTimeFormat\r\n        setDateTimeFormat(locale, format) {\r\n            composer.setDateTimeFormat(locale, format);\r\n        },\r\n        // mergeDateTimeFormat\r\n        mergeDateTimeFormat(locale, format) {\r\n            composer.mergeDateTimeFormat(locale, format);\r\n        },\r\n        // n\r\n        n(...args) {\r\n            return composer.n(...args);\r\n        },\r\n        // getNumberFormat\r\n        getNumberFormat(locale) {\r\n            return composer.getNumberFormat(locale);\r\n        },\r\n        // setNumberFormat\r\n        setNumberFormat(locale, format) {\r\n            composer.setNumberFormat(locale, format);\r\n        },\r\n        // mergeNumberFormat\r\n        mergeNumberFormat(locale, format) {\r\n            composer.mergeNumberFormat(locale, format);\r\n        },\r\n        // getChoiceIndex\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        getChoiceIndex(choice, choicesLength) {\r\n            ( false) &&\r\n                false;\r\n            return -1;\r\n        },\r\n        // for internal\r\n        __onComponentInstanceCreated(target) {\r\n            const { componentInstanceCreatedListener } = options;\r\n            if (componentInstanceCreatedListener) {\r\n                componentInstanceCreatedListener(target, vueI18n);\r\n            }\r\n        }\r\n    };\r\n    // for vue-devtools timeline event\r\n    if ((false)) {}\r\n    return vueI18n;\r\n}\n\nconst baseFormatProps = {\r\n    tag: {\r\n        type: [String, Object]\r\n    },\r\n    locale: {\r\n        type: String\r\n    },\r\n    scope: {\r\n        type: String,\r\n        validator: (val) => val === \'parent\' || val === \'global\',\r\n        default: \'parent\'\r\n    }\r\n};\n\n/**\r\n * Translation Component\r\n *\r\n * @remarks\r\n * See the following items for property about details\r\n *\r\n * @VueI18nSee [TranslationProps](component#translationprops)\r\n * @VueI18nSee [BaseFormatProps](component#baseformatprops)\r\n * @VueI18nSee [Component Interpolation](../advanced/component)\r\n *\r\n * @example\r\n * ```html\r\n * <div id="app">\r\n *   \x3c!-- ... --\x3e\r\n *   <i18n path="term" tag="label" for="tos">\r\n *     <a :href="url" target="_blank">{{ $t(\'tos\') }}</a>\r\n *   </i18n>\r\n *   \x3c!-- ... --\x3e\r\n * </div>\r\n * ```\r\n * ```js\r\n * import { createApp } from \'vue\'\r\n * import { createI18n } from \'vue-i18n\'\r\n *\r\n * const messages = {\r\n *   en: {\r\n *     tos: \'Term of Service\',\r\n *     term: \'I accept xxx {0}.\'\r\n *   },\r\n *   ja: {\r\n *     tos: \'利用規約\',\r\n *     term: \'私は xxx の{0}に同意します。\'\r\n *   }\r\n * }\r\n *\r\n * const i18n = createI18n({\r\n *   locale: \'en\',\r\n *   messages\r\n * })\r\n *\r\n * const app = createApp({\r\n *   data: {\r\n *     url: \'/term\'\r\n *   }\r\n * }).use(i18n).mount(\'#app\')\r\n * ```\r\n *\r\n * @VueI18nComponent\r\n */\r\nconst Translation = {\r\n    /* eslint-disable */\r\n    name: \'i18n-t\',\r\n    props: {\r\n        ...baseFormatProps,\r\n        keypath: {\r\n            type: String,\r\n            required: true\r\n        },\r\n        plural: {\r\n            type: [Number, String],\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            validator: (val) => Object(shared_esm_bundler["j" /* isNumber */])(val) || !isNaN(val)\r\n        }\r\n    },\r\n    /* eslint-enable */\r\n    setup(props, context) {\r\n        const { slots, attrs } = context;\r\n        const i18n = useI18n({ useScope: props.scope });\r\n        const keys = Object.keys(slots).filter(key => key !== \'_\');\r\n        return () => {\r\n            const options = {};\r\n            if (props.locale) {\r\n                options.locale = props.locale;\r\n            }\r\n            if (props.plural !== undefined) {\r\n                options.plural = Object(shared_esm_bundler["n" /* isString */])(props.plural) ? +props.plural : props.plural;\r\n            }\r\n            const arg = getInterpolateArg(context, keys);\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const children = i18n[TransrateVNodeSymbol](props.keypath, arg, options);\r\n            // prettier-ignore\r\n            return Object(shared_esm_bundler["n" /* isString */])(props.tag)\r\n                ? Object(vue_runtime_esm_bundler["h"])(props.tag, { ...attrs }, children)\r\n                : Object(shared_esm_bundler["k" /* isObject */])(props.tag)\r\n                    ? Object(vue_runtime_esm_bundler["h"])(props.tag, { ...attrs }, children)\r\n                    : Object(vue_runtime_esm_bundler["h"])(vue_runtime_esm_bundler["Fragment"], { ...attrs }, children);\r\n        };\r\n    }\r\n};\r\nfunction getInterpolateArg({ slots }, keys) {\r\n    if (keys.length === 1 && keys[0] === \'default\') {\r\n        // default slot only\r\n        return slots.default ? slots.default() : [];\r\n    }\r\n    else {\r\n        // named slots\r\n        return keys.reduce((arg, key) => {\r\n            const slot = slots[key];\r\n            if (slot) {\r\n                arg[key] = slot();\r\n            }\r\n            return arg;\r\n        }, {});\r\n    }\r\n}\n\nfunction renderFormatter(props, context, slotKeys, partFormatter) {\r\n    const { slots, attrs } = context;\r\n    return () => {\r\n        const options = { part: true };\r\n        let orverrides = {};\r\n        if (props.locale) {\r\n            options.locale = props.locale;\r\n        }\r\n        if (Object(shared_esm_bundler["n" /* isString */])(props.format)) {\r\n            options.key = props.format;\r\n        }\r\n        else if (Object(shared_esm_bundler["k" /* isObject */])(props.format)) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            if (Object(shared_esm_bundler["n" /* isString */])(props.format.key)) {\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                options.key = props.format.key;\r\n            }\r\n            // Filter out number format options only\r\n            orverrides = Object.keys(props.format).reduce((options, prop) => {\r\n                return slotKeys.includes(prop)\r\n                    ? Object.assign({}, options, { [prop]: props.format[prop] }) // eslint-disable-line @typescript-eslint/no-explicit-any\r\n                    : options;\r\n            }, {});\r\n        }\r\n        const parts = partFormatter(...[props.value, options, orverrides]);\r\n        let children = [options.key];\r\n        if (Object(shared_esm_bundler["e" /* isArray */])(parts)) {\r\n            children = parts.map((part, index) => {\r\n                const slot = slots[part.type];\r\n                return slot\r\n                    ? slot({ [part.type]: part.value, index, parts })\r\n                    : [part.value];\r\n            });\r\n        }\r\n        else if (Object(shared_esm_bundler["n" /* isString */])(parts)) {\r\n            children = [parts];\r\n        }\r\n        // prettier-ignore\r\n        return Object(shared_esm_bundler["n" /* isString */])(props.tag)\r\n            ? Object(vue_runtime_esm_bundler["h"])(props.tag, { ...attrs }, children)\r\n            : Object(shared_esm_bundler["k" /* isObject */])(props.tag)\r\n                ? Object(vue_runtime_esm_bundler["h"])(props.tag, { ...attrs }, children)\r\n                : Object(vue_runtime_esm_bundler["h"])(vue_runtime_esm_bundler["Fragment"], { ...attrs }, children);\r\n    };\r\n}\n\nconst NUMBER_FORMAT_KEYS = [\r\n    \'localeMatcher\',\r\n    \'style\',\r\n    \'unit\',\r\n    \'unitDisplay\',\r\n    \'currency\',\r\n    \'currencyDisplay\',\r\n    \'useGrouping\',\r\n    \'numberingSystem\',\r\n    \'minimumIntegerDigits\',\r\n    \'minimumFractionDigits\',\r\n    \'maximumFractionDigits\',\r\n    \'minimumSignificantDigits\',\r\n    \'maximumSignificantDigits\',\r\n    \'notation\',\r\n    \'formatMatcher\'\r\n];\r\n/**\r\n * Number Format Component\r\n *\r\n * @remarks\r\n * See the following items for property about details\r\n *\r\n * @VueI18nSee [FormattableProps](component#formattableprops)\r\n * @VueI18nSee [BaseFormatProps](component#baseformatprops)\r\n * @VueI18nSee [Custom Formatting](../essentials/number#custom-formatting)\r\n *\r\n * @VueI18nDanger\r\n * Not supported IE, due to no support `Intl.NumberForamt#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/formatToParts)\r\n *\r\n * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-numberformat)\r\n *\r\n * @VueI18nComponent\r\n */\r\nconst NumberFormat = {\r\n    /* eslint-disable */\r\n    name: \'i18n-n\',\r\n    props: {\r\n        ...baseFormatProps,\r\n        value: {\r\n            type: Number,\r\n            required: true\r\n        },\r\n        format: {\r\n            type: [String, Object]\r\n        }\r\n    },\r\n    /* eslint-enable */\r\n    setup(props, context) {\r\n        const i18n = useI18n({ useScope: \'parent\' });\r\n        return renderFormatter(props, context, NUMBER_FORMAT_KEYS, (...args) => \r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        i18n[NumberPartsSymbol](...args));\r\n    }\r\n};\n\nconst DATETIME_FORMAT_KEYS = [\r\n    \'dateStyle\',\r\n    \'timeStyle\',\r\n    \'fractionalSecondDigits\',\r\n    \'calendar\',\r\n    \'dayPeriod\',\r\n    \'numberingSystem\',\r\n    \'localeMatcher\',\r\n    \'timeZone\',\r\n    \'hour12\',\r\n    \'hourCycle\',\r\n    \'formatMatcher\',\r\n    \'weekday\',\r\n    \'era\',\r\n    \'year\',\r\n    \'month\',\r\n    \'day\',\r\n    \'hour\',\r\n    \'minute\',\r\n    \'second\',\r\n    \'timeZoneName\'\r\n];\r\n/**\r\n * Datetime Format Component\r\n *\r\n * @remarks\r\n * See the following items for property about details\r\n *\r\n * @VueI18nSee [FormattableProps](component#formattableprops)\r\n * @VueI18nSee [BaseFormatProps](component#baseformatprops)\r\n * @VueI18nSee [Custom Formatting](../essentials/datetime#custom-formatting)\r\n *\r\n * @VueI18nDanger\r\n * Not supported IE, due to no support `Intl.DateTimeForamt#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts)\r\n *\r\n * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-datetimeformat)\r\n *\r\n * @VueI18nComponent\r\n */\r\nconst DatetimeFormat = {\r\n    /* eslint-disable */\r\n    name: \'i18n-d\',\r\n    props: {\r\n        ...baseFormatProps,\r\n        value: {\r\n            type: [Number, Date],\r\n            required: true\r\n        },\r\n        format: {\r\n            type: [String, Object]\r\n        }\r\n    },\r\n    /* eslint-enable */\r\n    setup(props, context) {\r\n        const i18n = useI18n({ useScope: \'parent\' });\r\n        return renderFormatter(props, context, DATETIME_FORMAT_KEYS, (...args) => \r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        i18n[DatetimePartsSymbol](...args));\r\n    }\r\n};\n\nfunction getComposer(i18n, instance) {\r\n    const i18nInternal = i18n;\r\n    if (i18n.mode === \'composition\') {\r\n        return (i18nInternal.__getInstance(instance) || i18n.global);\r\n    }\r\n    else {\r\n        const vueI18n = i18nInternal.__getInstance(instance);\r\n        return vueI18n != null\r\n            ? vueI18n.__composer\r\n            : i18n.global.__composer;\r\n    }\r\n}\r\nfunction vTDirective(i18n) {\r\n    const bind = (el, { instance, value, modifiers }) => {\r\n        /* istanbul ignore if */\r\n        if (!instance || !instance.$) {\r\n            throw createI18nError(20 /* UNEXPECTED_ERROR */);\r\n        }\r\n        const composer = getComposer(i18n, instance.$);\r\n        if (false) {}\r\n        const parsedValue = parseValue(value);\r\n        el.textContent = composer.t(...makeParams(parsedValue));\r\n    };\r\n    return {\r\n        beforeMount: bind,\r\n        beforeUpdate: bind\r\n    };\r\n}\r\nfunction parseValue(value) {\r\n    if (Object(shared_esm_bundler["n" /* isString */])(value)) {\r\n        return { path: value };\r\n    }\r\n    else if (Object(shared_esm_bundler["l" /* isPlainObject */])(value)) {\r\n        if (!(\'path\' in value)) {\r\n            throw createI18nError(17 /* REQUIRED_VALUE */, \'path\');\r\n        }\r\n        return value;\r\n    }\r\n    else {\r\n        throw createI18nError(18 /* INVALID_VALUE */);\r\n    }\r\n}\r\nfunction makeParams(value) {\r\n    const { path, locale, args, choice, plural } = value;\r\n    const options = {};\r\n    const named = args || {};\r\n    if (Object(shared_esm_bundler["n" /* isString */])(locale)) {\r\n        options.locale = locale;\r\n    }\r\n    if (Object(shared_esm_bundler["j" /* isNumber */])(choice)) {\r\n        options.plural = choice;\r\n    }\r\n    if (Object(shared_esm_bundler["j" /* isNumber */])(plural)) {\r\n        options.plural = plural;\r\n    }\r\n    return [path, named, options];\r\n}\n\nfunction apply(app, i18n, ...options) {\r\n    const pluginOptions = Object(shared_esm_bundler["l" /* isPlainObject */])(options[0])\r\n        ? options[0]\r\n        : {};\r\n    const useI18nComponentName = !!pluginOptions.useI18nComponentName;\r\n    const globalInstall = Object(shared_esm_bundler["f" /* isBoolean */])(pluginOptions.globalInstall)\r\n        ? pluginOptions.globalInstall\r\n        : true;\r\n    if (false) {}\r\n    if (globalInstall) {\r\n        // install components\r\n        app.component(!useI18nComponentName ? Translation.name : \'i18n\', Translation);\r\n        app.component(NumberFormat.name, NumberFormat);\r\n        app.component(DatetimeFormat.name, DatetimeFormat);\r\n    }\r\n    // install directive\r\n    app.directive(\'t\', vTDirective(i18n));\r\n}\n\n// supports compatibility for legacy vue-i18n APIs\r\nfunction defineMixin(vuei18n, composer, i18n) {\r\n    return {\r\n        beforeCreate() {\r\n            const instance = Object(vue_runtime_esm_bundler["getCurrentInstance"])();\r\n            /* istanbul ignore if */\r\n            if (!instance) {\r\n                throw createI18nError(20 /* UNEXPECTED_ERROR */);\r\n            }\r\n            const options = this.$options;\r\n            if (options.i18n) {\r\n                const optionsI18n = options.i18n;\r\n                if (options.__i18n) {\r\n                    optionsI18n.__i18n = options.__i18n;\r\n                }\r\n                optionsI18n.__root = composer;\r\n                if (this === this.$root) {\r\n                    this.$i18n = mergeToRoot(vuei18n, optionsI18n);\r\n                }\r\n                else {\r\n                    this.$i18n = createVueI18n(optionsI18n);\r\n                }\r\n            }\r\n            else if (options.__i18n) {\r\n                if (this === this.$root) {\r\n                    this.$i18n = mergeToRoot(vuei18n, options);\r\n                }\r\n                else {\r\n                    this.$i18n = createVueI18n({\r\n                        __i18n: options.__i18n,\r\n                        __root: composer\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                // set global\r\n                this.$i18n = vuei18n;\r\n            }\r\n            vuei18n.__onComponentInstanceCreated(this.$i18n);\r\n            i18n.__setInstance(instance, this.$i18n);\r\n            // defines vue-i18n legacy APIs\r\n            this.$t = (...args) => this.$i18n.t(...args);\r\n            this.$tc = (...args) => this.$i18n.tc(...args);\r\n            this.$te = (key, locale) => this.$i18n.te(key, locale);\r\n            this.$d = (...args) => this.$i18n.d(...args);\r\n            this.$n = (...args) => this.$i18n.n(...args);\r\n            this.$tm = (key) => this.$i18n.tm(key);\r\n        },\r\n        mounted() {\r\n            /* istanbul ignore if */\r\n            if ((( false) || __INTLIFY_PROD_DEVTOOLS__) && !false) {\r\n                this.$el.__INTLIFY__ = this.$i18n.__composer;\r\n                const emitter = (this.__emitter = createEmitter());\r\n                const _vueI18n = this.$i18n;\r\n                _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);\r\n                emitter.on(\'*\', addTimelineEvent);\r\n            }\r\n        },\r\n        beforeUnmount() {\r\n            const instance = Object(vue_runtime_esm_bundler["getCurrentInstance"])();\r\n            /* istanbul ignore if */\r\n            if (!instance) {\r\n                throw createI18nError(20 /* UNEXPECTED_ERROR */);\r\n            }\r\n            /* istanbul ignore if */\r\n            if ((( false) || __INTLIFY_PROD_DEVTOOLS__) && !false) {\r\n                if (this.__emitter) {\r\n                    this.__emitter.off(\'*\', addTimelineEvent);\r\n                    delete this.__emitter;\r\n                }\r\n                const _vueI18n = this.$i18n;\r\n                _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();\r\n                delete this.$el.__INTLIFY__;\r\n            }\r\n            delete this.$t;\r\n            delete this.$tc;\r\n            delete this.$te;\r\n            delete this.$d;\r\n            delete this.$n;\r\n            delete this.$tm;\r\n            i18n.__deleteInstance(instance);\r\n            delete this.$i18n;\r\n        }\r\n    };\r\n}\r\nfunction mergeToRoot(root, optoins) {\r\n    root.locale = optoins.locale || root.locale;\r\n    root.fallbackLocale = optoins.fallbackLocale || root.fallbackLocale;\r\n    root.missing = optoins.missing || root.missing;\r\n    root.silentTranslationWarn =\r\n        optoins.silentTranslationWarn || root.silentFallbackWarn;\r\n    root.silentFallbackWarn =\r\n        optoins.silentFallbackWarn || root.silentFallbackWarn;\r\n    root.formatFallbackMessages =\r\n        optoins.formatFallbackMessages || root.formatFallbackMessages;\r\n    root.postTranslation = optoins.postTranslation || root.postTranslation;\r\n    root.warnHtmlInMessage = optoins.warnHtmlInMessage || root.warnHtmlInMessage;\r\n    root.escapeParameterHtml =\r\n        optoins.escapeParameterHtml || root.escapeParameterHtml;\r\n    root.sync = optoins.sync || root.sync;\r\n    const messages = getLocaleMessages(root.locale, {\r\n        messages: optoins.messages,\r\n        __i18n: optoins.__i18n\r\n    });\r\n    Object.keys(messages).forEach(locale => root.mergeLocaleMessage(locale, messages[locale]));\r\n    if (optoins.datetimeFormats) {\r\n        Object.keys(optoins.datetimeFormats).forEach(locale => root.mergeDateTimeFormat(locale, optoins.datetimeFormats[locale]));\r\n    }\r\n    if (optoins.numberFormats) {\r\n        Object.keys(optoins.numberFormats).forEach(locale => root.mergeNumberFormat(locale, optoins.numberFormats[locale]));\r\n    }\r\n    return root;\r\n}\n\n/**\r\n * Vue I18n factory\r\n *\r\n * @param options - An options, see the {@link I18nOptions}\r\n *\r\n * @returns {@link I18n} instance\r\n *\r\n * @remarks\r\n * If you use Legacy API mode, you need toto specify {@link VueI18nOptions} and `legacy: true` option.\r\n *\r\n * If you use composition API mode, you need to specify {@link ComposerOptions}.\r\n *\r\n * @VueI18nSee [Getting Started](../essentials/started)\r\n * @VueI18nSee [Composition API](../advanced/composition)\r\n *\r\n * @example\r\n * case: for Legacy API\r\n * ```js\r\n * import { createApp } from \'vue\'\r\n * import { createI18n } from \'vue-i18n\'\r\n *\r\n * // call with I18n option\r\n * const i18n = createI18n({\r\n *   locale: \'ja\',\r\n *   messages: {\r\n *     en: { ... },\r\n *     ja: { ... }\r\n *   }\r\n * })\r\n *\r\n * const App = {\r\n *   // ...\r\n * }\r\n *\r\n * const app = createApp(App)\r\n *\r\n * // install!\r\n * app.use(i18n)\r\n * app.mount(\'#app\')\r\n * ```\r\n *\r\n * @example\r\n * case: for composition API\r\n * ```js\r\n * import { createApp } from \'vue\'\r\n * import { createI18n, useI18n } from \'vue-i18n\'\r\n *\r\n * // call with I18n option\r\n * const i18n = createI18n({\r\n *   legacy: false, // you must specify \'lagacy: false\' option\r\n *   locale: \'ja\',\r\n *   messages: {\r\n *     en: { ... },\r\n *     ja: { ... }\r\n *   }\r\n * })\r\n *\r\n * const App = {\r\n *   setup() {\r\n *     // ...\r\n *     const { t } = useI18n({ ... })\r\n *     return { ... , t }\r\n *   }\r\n * }\r\n *\r\n * const app = createApp(App)\r\n *\r\n * // install!\r\n * app.use(i18n)\r\n * app.mount(\'#app\')\r\n * ```\r\n *\r\n * @VueI18nGeneral\r\n */\r\nfunction createI18n(options = {}) {\r\n    // prettier-ignore\r\n    const __legacyMode = __VUE_I18N_LEGACY_API__ && Object(shared_esm_bundler["f" /* isBoolean */])(options.legacy)\r\n        ? options.legacy\r\n        : true;\r\n    const __globalInjection = __VUE_I18N_LEGACY_API__ && !!options.globalInjection;\r\n    const __instances = new Map();\r\n    // prettier-ignore\r\n    const __global = __VUE_I18N_LEGACY_API__ && __legacyMode\r\n        ? createVueI18n(options)\r\n        : createComposer(options);\r\n    const symbol = Object(shared_esm_bundler["o" /* makeSymbol */])(( false) ? undefined : \'\');\r\n    const i18n = {\r\n        // mode\r\n        get mode() {\r\n            // prettier-ignore\r\n            return __VUE_I18N_LEGACY_API__\r\n                ? __legacyMode\r\n                    ? \'legacy\'\r\n                    : \'composition\'\r\n                : \'composition\';\r\n        },\r\n        // install plugin\r\n        async install(app, ...options) {\r\n            if ((( false) || __INTLIFY_PROD_DEVTOOLS__) && !false) {\r\n                app.__VUE_I18N__ = i18n;\r\n            }\r\n            // setup global provider\r\n            app.__VUE_I18N_SYMBOL__ = symbol;\r\n            app.provide(app.__VUE_I18N_SYMBOL__, i18n);\r\n            // global method and properties injection for Composition API\r\n            if (!__legacyMode && __globalInjection) {\r\n                injectGlobalFields(app, i18n.global);\r\n            }\r\n            // install built-in components and directive\r\n            if (__VUE_I18N_FULL_INSTALL__) {\r\n                apply(app, i18n, ...options);\r\n            }\r\n            // setup mixin for Legacy API\r\n            if (__VUE_I18N_LEGACY_API__ && __legacyMode) {\r\n                app.mixin(defineMixin(__global, __global.__composer, i18n));\r\n            }\r\n            // setup vue-devtools plugin\r\n            if ((( false) || __INTLIFY_PROD_DEVTOOLS__) && !false) {\r\n                const ret = await enableDevTools(app, i18n);\r\n                if (!ret) {\r\n                    throw createI18nError(19 /* CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN */);\r\n                }\r\n                const emitter = createEmitter();\r\n                if (__legacyMode) {\r\n                    const _vueI18n = __global;\r\n                    _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);\r\n                }\r\n                else {\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    const _composer = __global;\r\n                    _composer[EnableEmitter] && _composer[EnableEmitter](emitter);\r\n                }\r\n                emitter.on(\'*\', addTimelineEvent);\r\n            }\r\n        },\r\n        // global accsessor\r\n        get global() {\r\n            return __global;\r\n        },\r\n        // @internal\r\n        __instances,\r\n        // @internal\r\n        __getInstance(component) {\r\n            return __instances.get(component) || null;\r\n        },\r\n        // @internal\r\n        __setInstance(component, instance) {\r\n            __instances.set(component, instance);\r\n        },\r\n        // @internal\r\n        __deleteInstance(component) {\r\n            __instances.delete(component);\r\n        }\r\n    };\r\n    if ((( false) || __INTLIFY_PROD_DEVTOOLS__) && !false) {\r\n        devtoolsRegisterI18n(i18n, VERSION);\r\n    }\r\n    return i18n;\r\n}\r\n/**\r\n * Use Composition API for Vue I18n\r\n *\r\n * @param options - An options, see {@link UseI18nOptions}\r\n *\r\n * @returns {@link Composer} instance\r\n *\r\n * @remarks\r\n * This function is mainly used by `setup`.\r\n *\r\n * If options are specified, Composer instance is created for each component and you can be localized on the component.\r\n *\r\n * If options are not specified, you can be localized using the global Composer.\r\n *\r\n * @example\r\n * case: Component resource base localization\r\n * ```html\r\n * <template>\r\n *   <form>\r\n *     <label>{{ t(\'language\') }}</label>\r\n *     <select v-model="locale">\r\n *       <option value="en">en</option>\r\n *       <option value="ja">ja</option>\r\n *     </select>\r\n *   </form>\r\n *   <p>message: {{ t(\'hello\') }}</p>\r\n * </template>\r\n *\r\n * <script>\r\n * import { useI18n } from \'vue-i18n\'\r\n *\r\n * export default {\r\n *  setup() {\r\n *    const { t, locale } = useI18n({\r\n *      locale: \'ja\',\r\n *      messages: {\r\n *        en: { ... },\r\n *        ja: { ... }\r\n *      }\r\n *    })\r\n *    // Something to do ...\r\n *\r\n *    return { ..., t, locale }\r\n *  }\r\n * }\r\n * <\/script>\r\n * ```\r\n *\r\n * @VueI18nComposition\r\n */\r\nfunction useI18n(options = {}) {\r\n    const instance = Object(vue_runtime_esm_bundler["getCurrentInstance"])();\r\n    if (instance == null) {\r\n        throw createI18nError(14 /* MUST_BE_CALL_SETUP_TOP */);\r\n    }\r\n    if (!instance.appContext.app.__VUE_I18N_SYMBOL__) {\r\n        throw createI18nError(15 /* NOT_INSLALLED */);\r\n    }\r\n    const i18n = Object(vue_runtime_esm_bundler["inject"])(instance.appContext.app.__VUE_I18N_SYMBOL__);\r\n    /* istanbul ignore if */\r\n    if (!i18n) {\r\n        throw createI18nError(20 /* UNEXPECTED_ERROR */);\r\n    }\r\n    // prettier-ignore\r\n    const global = i18n.mode === \'composition\'\r\n        ? i18n.global\r\n        : i18n.global.__composer;\r\n    // prettier-ignore\r\n    const scope = Object(shared_esm_bundler["h" /* isEmptyObject */])(options)\r\n        ? (\'__i18n\' in instance.type)\r\n            ? \'local\'\r\n            : \'global\'\r\n        : !options.useScope\r\n            ? \'local\'\r\n            : options.useScope;\r\n    if (scope === \'global\') {\r\n        let messages = Object(shared_esm_bundler["k" /* isObject */])(options.messages) ? options.messages : {};\r\n        if (\'__i18nGlobal\' in instance.type) {\r\n            messages = getLocaleMessages(global.locale.value, {\r\n                messages,\r\n                __i18n: instance.type.__i18nGlobal\r\n            });\r\n        }\r\n        // merge locale messages\r\n        const locales = Object.keys(messages);\r\n        if (locales.length) {\r\n            locales.forEach(locale => {\r\n                global.mergeLocaleMessage(locale, messages[locale]);\r\n            });\r\n        }\r\n        // merge datetime formats\r\n        if (Object(shared_esm_bundler["k" /* isObject */])(options.datetimeFormats)) {\r\n            const locales = Object.keys(options.datetimeFormats);\r\n            if (locales.length) {\r\n                locales.forEach(locale => {\r\n                    global.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);\r\n                });\r\n            }\r\n        }\r\n        // merge number formats\r\n        if (Object(shared_esm_bundler["k" /* isObject */])(options.numberFormats)) {\r\n            const locales = Object.keys(options.numberFormats);\r\n            if (locales.length) {\r\n                locales.forEach(locale => {\r\n                    global.mergeNumberFormat(locale, options.numberFormats[locale]);\r\n                });\r\n            }\r\n        }\r\n        return global;\r\n    }\r\n    if (scope === \'parent\') {\r\n        let composer = getComposer$1(i18n, instance);\r\n        if (composer == null) {\r\n            if ((false)) {}\r\n            composer = global;\r\n        }\r\n        return composer;\r\n    }\r\n    // scope \'local\' case\r\n    if (i18n.mode === \'legacy\') {\r\n        throw createI18nError(16 /* NOT_AVAILABLE_IN_LEGACY_MODE */);\r\n    }\r\n    const i18nInternal = i18n;\r\n    let composer = i18nInternal.__getInstance(instance);\r\n    if (composer == null) {\r\n        const type = instance.type;\r\n        const composerOptions = {\r\n            ...options\r\n        };\r\n        if (type.__i18n) {\r\n            composerOptions.__i18n = type.__i18n;\r\n        }\r\n        if (global) {\r\n            composerOptions.__root = global;\r\n        }\r\n        composer = createComposer(composerOptions);\r\n        setupLifeCycle(i18nInternal, instance, composer);\r\n        i18nInternal.__setInstance(instance, composer);\r\n    }\r\n    return composer;\r\n}\r\nfunction getComposer$1(i18n, target) {\r\n    let composer = null;\r\n    const root = target.root;\r\n    let current = target.parent;\r\n    while (current != null) {\r\n        const i18nInternal = i18n;\r\n        if (i18n.mode === \'composition\') {\r\n            composer = i18nInternal.__getInstance(current);\r\n        }\r\n        else {\r\n            const vueI18n = i18nInternal.__getInstance(current);\r\n            if (vueI18n != null) {\r\n                composer = vueI18n\r\n                    .__composer;\r\n            }\r\n        }\r\n        if (composer != null) {\r\n            break;\r\n        }\r\n        if (root === current) {\r\n            break;\r\n        }\r\n        current = current.parent;\r\n    }\r\n    return composer;\r\n}\r\nfunction setupLifeCycle(i18n, target, composer) {\r\n    let emitter = null;\r\n    Object(vue_runtime_esm_bundler["onMounted"])(() => {\r\n        // inject composer instance to DOM for intlify-devtools\r\n        if ((( false) || __INTLIFY_PROD_DEVTOOLS__) &&\r\n            !false &&\r\n            target.vnode.el) {\r\n            target.vnode.el.__INTLIFY__ = composer;\r\n            emitter = createEmitter();\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const _composer = composer;\r\n            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);\r\n            emitter.on(\'*\', addTimelineEvent);\r\n        }\r\n    }, target);\r\n    Object(vue_runtime_esm_bundler["onUnmounted"])(() => {\r\n        // remove composer instance from DOM for intlify-devtools\r\n        if ((( false) || __INTLIFY_PROD_DEVTOOLS__) &&\r\n            !false &&\r\n            target.vnode.el &&\r\n            target.vnode.el.__INTLIFY__) {\r\n            emitter && emitter.off(\'*\', addTimelineEvent);\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const _composer = composer;\r\n            _composer[DisableEmitter] && _composer[DisableEmitter]();\r\n            delete target.vnode.el.__INTLIFY__;\r\n        }\r\n        i18n.__deleteInstance(target);\r\n    }, target);\r\n}\r\nconst globalExportProps = [\r\n    \'locale\',\r\n    \'fallbackLocale\',\r\n    \'availableLocales\'\r\n];\r\nconst globalExportMethods = [\'t\', \'d\', \'n\', \'tm\'];\r\nfunction injectGlobalFields(app, composer) {\r\n    const i18n = Object.create(null);\r\n    globalExportProps.forEach(prop => {\r\n        const desc = Object.getOwnPropertyDescriptor(composer, prop);\r\n        if (!desc) {\r\n            throw createI18nError(20 /* UNEXPECTED_ERROR */);\r\n        }\r\n        const wrap = Object(vue_runtime_esm_bundler["isRef"])(desc.value) // check computed props\r\n            ? {\r\n                get() {\r\n                    return desc.value.value;\r\n                },\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                set(val) {\r\n                    desc.value.value = val;\r\n                }\r\n            }\r\n            : {\r\n                get() {\r\n                    return desc.get && desc.get();\r\n                }\r\n            };\r\n        Object.defineProperty(i18n, prop, wrap);\r\n    });\r\n    app.config.globalProperties.$i18n = i18n;\r\n    globalExportMethods.forEach(method => {\r\n        const desc = Object.getOwnPropertyDescriptor(composer, method);\r\n        if (!desc) {\r\n            throw createI18nError(20 /* UNEXPECTED_ERROR */);\r\n        }\r\n        Object.defineProperty(app.config.globalProperties, `$${method}`, desc);\r\n    });\r\n}\n\n// register message compiler at vue-i18n\r\nregisterMessageCompiler(compileToFunction);\r\n{\r\n    initFeatureFlags();\r\n}\r\n( false) && false;\n\n\n\n\n//# sourceURL=webpack:///./node_modules/vue-i18n/dist/vue-i18n.esm-bundler.js_+_4_modules?')},897:function(module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.setupDevtoolsPlugin = void 0;\nconst env_1 = __webpack_require__(898);\nconst const_1 = __webpack_require__(899);\n__exportStar(__webpack_require__(900), exports);\nfunction setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    if (env_1.hook) {\n        env_1.hook.emit(const_1.ApiHookEvents.SETUP_DEVTOOLS_PLUGIN, pluginDescriptor, setupFn);\n    }\n    else {\n        const list = env_1.target.__VUE_DEVTOOLS_PLUGINS__ = env_1.target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor,\n            setupFn\n        });\n    }\n}\nexports.setupDevtoolsPlugin = setupDevtoolsPlugin;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/index.js?')},898:function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hook = exports.target = exports.isBrowser = void 0;\nexports.isBrowser = typeof navigator !== 'undefined';\nexports.target = exports.isBrowser\n    ? window\n    : typeof global !== 'undefined'\n        ? global\n        : {};\nexports.hook = exports.target.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n//# sourceMappingURL=env.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/env.js?")},899:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.ApiHookEvents = void 0;\nvar ApiHookEvents;\n(function (ApiHookEvents) {\n    ApiHookEvents["SETUP_DEVTOOLS_PLUGIN"] = "devtools-plugin:setup";\n})(ApiHookEvents = exports.ApiHookEvents || (exports.ApiHookEvents = {}));\n//# sourceMappingURL=const.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/const.js?')},900:function(module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", { value: true });\n__exportStar(__webpack_require__(901), exports);\n__exportStar(__webpack_require__(902), exports);\n__exportStar(__webpack_require__(903), exports);\n__exportStar(__webpack_require__(904), exports);\n__exportStar(__webpack_require__(905), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/api/index.js?')},901:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/api/api.js?')},902:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n//# sourceMappingURL=app.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/api/app.js?')},903:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n//# sourceMappingURL=component.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/api/component.js?')},904:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n//# sourceMappingURL=context.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/api/context.js?')},905:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.Hooks = void 0;\nvar Hooks;\n(function (Hooks) {\n    Hooks["TRANSFORM_CALL"] = "transformCall";\n    Hooks["GET_APP_RECORD_NAME"] = "getAppRecordName";\n    Hooks["GET_APP_ROOT_INSTANCE"] = "getAppRootInstance";\n    Hooks["REGISTER_APPLICATION"] = "registerApplication";\n    Hooks["WALK_COMPONENT_TREE"] = "walkComponentTree";\n    Hooks["WALK_COMPONENT_PARENTS"] = "walkComponentParents";\n    Hooks["INSPECT_COMPONENT"] = "inspectComponent";\n    Hooks["GET_COMPONENT_BOUNDS"] = "getComponentBounds";\n    Hooks["GET_COMPONENT_NAME"] = "getComponentName";\n    Hooks["GET_ELEMENT_COMPONENT"] = "getElementComponent";\n    Hooks["GET_INSPECTOR_TREE"] = "getInspectorTree";\n    Hooks["GET_INSPECTOR_STATE"] = "getInspectorState";\n})(Hooks = exports.Hooks || (exports.Hooks = {}));\n//# sourceMappingURL=hooks.js.map\n\n//# sourceURL=webpack:///./node_modules/@vue/devtools-api/lib/api/hooks.js?')}}]);